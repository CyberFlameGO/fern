// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateClientProject auth 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/index.ts": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
  "/model/auth/_service-types/ServiceWithBasicAuth/endpointBErrorBody.ts": "export type endpointBErrorBody = never;

export declare namespace endpointBErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointBErrorBody = {
    _visit: <Result>(_value: endpointBErrorBody, visitor: endpointBErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointBErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBasicAuth/endpointBResponse.ts": "import * as model from \\"../../..\\";

export type endpointBResponse = endpointBResponse.SuccessResponse | endpointBResponse.ErrorResponse;

export declare namespace endpointBResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointBErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithBasicAuth/index.ts": "export * from \\"./endpointBErrorBody\\";
export * from \\"./endpointBResponse\\";
",
  "/model/auth/_service-types/ServiceWithBasicAuthWithOverride/endpointGErrorBody.ts": "export type endpointGErrorBody = never;

export declare namespace endpointGErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointGErrorBody = {
    _visit: <Result>(_value: endpointGErrorBody, visitor: endpointGErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointGErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBasicAuthWithOverride/endpointGResponse.ts": "import * as model from \\"../../..\\";

export type endpointGResponse = endpointGResponse.SuccessResponse | endpointGResponse.ErrorResponse;

export declare namespace endpointGResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointGErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithBasicAuthWithOverride/index.ts": "export * from \\"./endpointGErrorBody\\";
export * from \\"./endpointGResponse\\";
export * from \\"./overrideEndpointGErrorBody\\";
export * from \\"./overrideEndpointGResponse\\";
",
  "/model/auth/_service-types/ServiceWithBasicAuthWithOverride/overrideEndpointGErrorBody.ts": "export type overrideEndpointGErrorBody = never;

export declare namespace overrideEndpointGErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const overrideEndpointGErrorBody = {
    _visit: <Result>(_value: overrideEndpointGErrorBody, visitor: overrideEndpointGErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): overrideEndpointGErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBasicAuthWithOverride/overrideEndpointGResponse.ts": "import * as model from \\"../../..\\";

export type overrideEndpointGResponse = overrideEndpointGResponse.SuccessResponse | overrideEndpointGResponse.ErrorResponse;

export declare namespace overrideEndpointGResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.overrideEndpointGErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithBearerAuth/endpointCErrorBody.ts": "export type endpointCErrorBody = never;

export declare namespace endpointCErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointCErrorBody = {
    _visit: <Result>(_value: endpointCErrorBody, visitor: endpointCErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointCErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBearerAuth/endpointCResponse.ts": "import * as model from \\"../../..\\";

export type endpointCResponse = endpointCResponse.SuccessResponse | endpointCResponse.ErrorResponse;

export declare namespace endpointCResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointCErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithBearerAuth/index.ts": "export * from \\"./endpointCErrorBody\\";
export * from \\"./endpointCResponse\\";
",
  "/model/auth/_service-types/ServiceWithBearerAuthWithOverride/endpointFErrorBody.ts": "export type endpointFErrorBody = never;

export declare namespace endpointFErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointFErrorBody = {
    _visit: <Result>(_value: endpointFErrorBody, visitor: endpointFErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointFErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBearerAuthWithOverride/endpointFResponse.ts": "import * as model from \\"../../..\\";

export type endpointFResponse = endpointFResponse.SuccessResponse | endpointFResponse.ErrorResponse;

export declare namespace endpointFResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointFErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithBearerAuthWithOverride/index.ts": "export * from \\"./endpointFErrorBody\\";
export * from \\"./endpointFResponse\\";
export * from \\"./overrideEndpointFErrorBody\\";
export * from \\"./overrideEndpointFResponse\\";
",
  "/model/auth/_service-types/ServiceWithBearerAuthWithOverride/overrideEndpointFErrorBody.ts": "export type overrideEndpointFErrorBody = never;

export declare namespace overrideEndpointFErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const overrideEndpointFErrorBody = {
    _visit: <Result>(_value: overrideEndpointFErrorBody, visitor: overrideEndpointFErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): overrideEndpointFErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithBearerAuthWithOverride/overrideEndpointFResponse.ts": "import * as model from \\"../../..\\";

export type overrideEndpointFResponse = overrideEndpointFResponse.SuccessResponse | overrideEndpointFResponse.ErrorResponse;

export declare namespace overrideEndpointFResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.overrideEndpointFErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithNoAuth/endpointAErrorBody.ts": "export type endpointAErrorBody = never;

export declare namespace endpointAErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointAErrorBody = {
    _visit: <Result>(_value: endpointAErrorBody, visitor: endpointAErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointAErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithNoAuth/endpointAResponse.ts": "import * as model from \\"../../..\\";

export type endpointAResponse = endpointAResponse.SuccessResponse | endpointAResponse.ErrorResponse;

export declare namespace endpointAResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointAErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithNoAuth/index.ts": "export * from \\"./endpointAErrorBody\\";
export * from \\"./endpointAResponse\\";
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBasicOverride/endpointEErrorBody.ts": "export type endpointEErrorBody = never;

export declare namespace endpointEErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointEErrorBody = {
    _visit: <Result>(_value: endpointEErrorBody, visitor: endpointEErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointEErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBasicOverride/endpointEResponse.ts": "import * as model from \\"../../..\\";

export type endpointEResponse = endpointEResponse.SuccessResponse | endpointEResponse.ErrorResponse;

export declare namespace endpointEResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointEErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBasicOverride/index.ts": "export * from \\"./endpointEErrorBody\\";
export * from \\"./endpointEResponse\\";
export * from \\"./overrideEndpointEErrorBody\\";
export * from \\"./overrideEndpointEResponse\\";
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBasicOverride/overrideEndpointEErrorBody.ts": "export type overrideEndpointEErrorBody = never;

export declare namespace overrideEndpointEErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const overrideEndpointEErrorBody = {
    _visit: <Result>(_value: overrideEndpointEErrorBody, visitor: overrideEndpointEErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): overrideEndpointEErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBasicOverride/overrideEndpointEResponse.ts": "import * as model from \\"../../..\\";

export type overrideEndpointEResponse = overrideEndpointEResponse.SuccessResponse | overrideEndpointEResponse.ErrorResponse;

export declare namespace overrideEndpointEResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.overrideEndpointEErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBearerOverride/endpointDErrorBody.ts": "export type endpointDErrorBody = never;

export declare namespace endpointDErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const endpointDErrorBody = {
    _visit: <Result>(_value: endpointDErrorBody, visitor: endpointDErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): endpointDErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBearerOverride/endpointDResponse.ts": "import * as model from \\"../../..\\";

export type endpointDResponse = endpointDResponse.SuccessResponse | endpointDResponse.ErrorResponse;

export declare namespace endpointDResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.endpointDErrorBody;
    }
}
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBearerOverride/index.ts": "export * from \\"./endpointDErrorBody\\";
export * from \\"./endpointDResponse\\";
export * from \\"./overrideEndpointDErrorBody\\";
export * from \\"./overrideEndpointDResponse\\";
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBearerOverride/overrideEndpointDErrorBody.ts": "export type overrideEndpointDErrorBody = never;

export declare namespace overrideEndpointDErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const overrideEndpointDErrorBody = {
    _visit: <Result>(_value: overrideEndpointDErrorBody, visitor: overrideEndpointDErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): overrideEndpointDErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/auth/_service-types/ServiceWithNoAuthWithBearerOverride/overrideEndpointDResponse.ts": "import * as model from \\"../../..\\";

export type overrideEndpointDResponse = overrideEndpointDResponse.SuccessResponse | overrideEndpointDResponse.ErrorResponse;

export declare namespace overrideEndpointDResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.auth.overrideEndpointDErrorBody;
    }
}
",
  "/model/auth/_service-types/index.ts": "export * from \\"./ServiceWithNoAuth\\";
export * from \\"./ServiceWithBasicAuth\\";
export * from \\"./ServiceWithBearerAuth\\";
export * from \\"./ServiceWithNoAuthWithBearerOverride\\";
export * from \\"./ServiceWithNoAuthWithBasicOverride\\";
export * from \\"./ServiceWithBearerAuthWithOverride\\";
export * from \\"./ServiceWithBasicAuthWithOverride\\";
",
  "/model/auth/_types/SomeType.ts": "export type SomeType = string;
",
  "/model/auth/_types/index.ts": "export * from \\"./SomeType\\";
",
  "/model/auth/index.ts": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
  "/model/index.ts": "export * as auth from \\"./auth\\";
",
  "/package.json": "{
    \\"name\\": \\"auth\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.184\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/services/auth/ServiceWithBasicAuth.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithBasicAuth {
    endpointB(): Promise<model.auth.endpointBResponse>;
}

export declare namespace ServiceWithBasicAuth {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithBasicAuth implements ServiceWithBasicAuth {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithBasicAuth.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointB(): Promise<model.auth.endpointBResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/b\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointBErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithBasicAuthWithOverride.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithBasicAuthWithOverride {
    endpointG(): Promise<model.auth.endpointGResponse>;
    overrideEndpointG(): Promise<model.auth.overrideEndpointGResponse>;
}

export declare namespace ServiceWithBasicAuthWithOverride {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithBasicAuthWithOverride implements ServiceWithBasicAuthWithOverride {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithBasicAuthWithOverride.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointG(): Promise<model.auth.endpointGResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/g\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointGErrorBody
            };
        }
    }

    public async overrideEndpointG(): Promise<model.auth.overrideEndpointGResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/g-override\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.overrideEndpointGErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithBearerAuth.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithBearerAuth {
    endpointC(): Promise<model.auth.endpointCResponse>;
}

export declare namespace ServiceWithBearerAuth {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithBearerAuth implements ServiceWithBearerAuth {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithBearerAuth.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointC(): Promise<model.auth.endpointCResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/c\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointCErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithBearerAuthWithOverride.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithBearerAuthWithOverride {
    endpointF(): Promise<model.auth.endpointFResponse>;
    overrideEndpointF(): Promise<model.auth.overrideEndpointFResponse>;
}

export declare namespace ServiceWithBearerAuthWithOverride {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithBearerAuthWithOverride implements ServiceWithBearerAuthWithOverride {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithBearerAuthWithOverride.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointF(): Promise<model.auth.endpointFResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/f\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointFErrorBody
            };
        }
    }

    public async overrideEndpointF(): Promise<model.auth.overrideEndpointFResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/f-override\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.overrideEndpointFErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithNoAuth.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithNoAuth {
    endpointA(): Promise<model.auth.endpointAResponse>;
}

export declare namespace ServiceWithNoAuth {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithNoAuth implements ServiceWithNoAuth {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithNoAuth.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointA(): Promise<model.auth.endpointAResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/a\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointAErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithNoAuthWithBasicOverride.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithNoAuthWithBasicOverride {
    endpointE(): Promise<model.auth.endpointEResponse>;
    overrideEndpointE(): Promise<model.auth.overrideEndpointEResponse>;
}

export declare namespace ServiceWithNoAuthWithBasicOverride {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithNoAuthWithBasicOverride implements ServiceWithNoAuthWithBasicOverride {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithNoAuthWithBasicOverride.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointE(): Promise<model.auth.endpointEResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/e\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointEErrorBody
            };
        }
    }

    public async overrideEndpointE(): Promise<model.auth.overrideEndpointEResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/e-override\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.overrideEndpointEErrorBody
            };
        }
    }
}
",
  "/services/auth/ServiceWithNoAuthWithBearerOverride.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ServiceWithNoAuthWithBearerOverride {
    endpointD(): Promise<model.auth.endpointDResponse>;
    overrideEndpointD(): Promise<model.auth.overrideEndpointDResponse>;
}

export declare namespace ServiceWithNoAuthWithBearerOverride {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ServiceWithNoAuthWithBearerOverride implements ServiceWithNoAuthWithBearerOverride {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ServiceWithNoAuthWithBearerOverride.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async endpointD(): Promise<model.auth.endpointDResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/d\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.endpointDErrorBody
            };
        }
    }

    public async overrideEndpointD(): Promise<model.auth.overrideEndpointDResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/d-override\\"),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.auth.overrideEndpointDErrorBody
            };
        }
    }
}
",
  "/services/auth/index.ts": "export * from \\"./ServiceWithNoAuth\\";
export * from \\"./ServiceWithBasicAuth\\";
export * from \\"./ServiceWithBearerAuth\\";
export * from \\"./ServiceWithNoAuthWithBearerOverride\\";
export * from \\"./ServiceWithNoAuthWithBasicOverride\\";
export * from \\"./ServiceWithBearerAuthWithOverride\\";
export * from \\"./ServiceWithBasicAuthWithOverride\\";
",
  "/services/index.ts": "export * as auth from \\"./auth\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
}
`;

exports[`generateClientProject chat 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/index.ts": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
  "/model/chat/_errors/GenericMessage.ts": "export type GenericMessage = string;
",
  "/model/chat/_errors/index.ts": "export * from \\"./GenericMessage\\";
",
  "/model/chat/_service-types/ChatService/index.ts": "export * from \\"./sendChatRequest\\";
export * from \\"./sendChatErrorBody\\";
export * from \\"./sendChatResponse\\";
",
  "/model/chat/_service-types/ChatService/sendChatErrorBody.ts": "import { chat } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type sendChatErrorBody =
    | sendChatErrorBody.GenericMessage;

export declare namespace sendChatErrorBody {
    interface GenericMessage {
        _error: \\"GenericMessage\\";
        _errorInstanceId: string;
        GenericMessage: chat.GenericMessage;
    }

    export interface _Visitor<Result> {
        GenericMessage: (value: chat.GenericMessage) => Result;
        _unknown: () => Result;
    }
}

export const sendChatErrorBody = {
    genericMessage: (value: chat.GenericMessage): sendChatErrorBody.GenericMessage => ({
        GenericMessage: value,
        _error: \\"GenericMessage\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: sendChatErrorBody, visitor: sendChatErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"GenericMessage\\": return visitor.GenericMessage(value.GenericMessage);
            default: return visitor._unknown();
        }
    },

    _types: (): sendChatErrorBody[\\"_error\\"][] => [\\"GenericMessage\\"],
} as const;
",
  "/model/chat/_service-types/ChatService/sendChatRequest.ts": "import * as model from \\"../../..\\";

export interface sendChatRequest {
    id: string;
    operation: \\"sendChat\\";
    body: model.chat.SendChatRequest;
}
",
  "/model/chat/_service-types/ChatService/sendChatResponse.ts": "import * as model from \\"../../..\\";

export type sendChatResponse = sendChatResponse.SuccessResponse | sendChatResponse.ErrorResponse;

export declare namespace sendChatResponse {
    export interface SuccessResponse {
        ok: true;
        id: string;
        replyTo: string;
        body: model.chat.ChatMessage;
    }

    export interface ErrorResponse {
        ok: false;
        id: string;
        replyTo: string;
        error: model.chat.sendChatErrorBody;
    }
}
",
  "/model/chat/_service-types/index.ts": "export * from \\"./ChatService\\";
",
  "/model/chat/_types/ChatMessage.ts": "import * as model from \\"../..\\";

export interface ChatMessage {
    id: model.chat.ChatMessageId;
    title: string;
    content: string;
}
",
  "/model/chat/_types/ChatMessageId.ts": "export type ChatMessageId = string;
",
  "/model/chat/_types/SendChatRequest.ts": "export interface SendChatRequest {
    title: string;
    content: string;
}
",
  "/model/chat/_types/index.ts": "export * from \\"./ChatMessageId\\";
export * from \\"./ChatMessage\\";
export * from \\"./SendChatRequest\\";
",
  "/model/chat/index.ts": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
  "/model/index.ts": "export * as chat from \\"./chat\\";
",
  "/package.json": "{
    \\"name\\": \\"chat\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/services/chat/ChatService.ts": "import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";
import * as uuid from \\"uuid\\";

export declare namespace ChatService {
    interface Args {
        origin: string;
    }

    type ServerMessage = model.chat.sendChatResponse;
}

export interface ChatService {
    sendChat(request: model.chat.SendChatRequest): Promise<model.chat.sendChatResponse>;
}

export class ChatService implements ChatService {
    private socket: Promise<WebSocket>;
    private callbacks: Record<string, (response: any) => void> = {};

    constructor(args: ChatService.Args) {
        this.socket = new Promise(resolve => {
            const socket = new WebSocket(urlJoin(args.origin, \\"/chat\\"));
            socket.onopen = () => {
                resolve(socket);
            };
            socket.onmessage = this._onMessage;
        });
    }

    public async sendChat(request: model.chat.SendChatRequest): Promise<model.chat.sendChatResponse> {
        const socket = await this.socket;

        return new Promise(resolve => {
            const message: model.chat.sendChatRequest = {
                id: uuid.v4(),
                operation: \\"sendChat\\",
                body: request
            };
            this.callbacks[message.id] = resolve;
            socket.send(JSON.stringify(message));
        });
    }

    public async _disconnect(): Promise<void> {
        const socket = await this.socket;
        return new Promise(resolve => {
            socket.onclose = () => {
                resolve();
            };
            socket.close();
        });
    }

    private _onMessage(event: MessageEvent): void {
        const message = JSON.parse(event.data) as ChatService.ServerMessage;
        if (\\"operation\\" in message) {
            console.log(\\"Received server message\\");
        }
        else {
            const callback = this.callbacks[message.replyTo];
            if (callback != null) {
                callback(message);
            }
            else {
                console.error(\\"Received reply to unknown request\\");
            }
        }
    }
}
",
  "/services/chat/index.ts": "export * from \\"./ChatService\\";
",
  "/services/index.ts": "export * as chat from \\"./chat\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
}
`;

exports[`generateClientProject no-errors 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/index.ts": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
  "/model/api/_service-types/NoErrorsService/getErrorBody.ts": "export type getErrorBody = never;

export declare namespace getErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const getErrorBody = {
    _visit: <Result>(_value: getErrorBody, visitor: getErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): getErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/api/_service-types/NoErrorsService/getResponse.ts": "import * as model from \\"../../..\\";

export type getResponse = getResponse.SuccessResponse | getResponse.ErrorResponse;

export declare namespace getResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.api.getErrorBody;
    }
}
",
  "/model/api/_service-types/NoErrorsService/index.ts": "export * from \\"./getErrorBody\\";
export * from \\"./getResponse\\";
",
  "/model/api/_service-types/index.ts": "export * from \\"./NoErrorsService\\";
",
  "/model/api/index.ts": "export * from \\"./_service-types\\";
",
  "/model/index.ts": "export * as api from \\"./api\\";
",
  "/package.json": "{
    \\"name\\": \\"no-errors\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.184\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/services/api/NoErrorsService.ts": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface NoErrorsService {
    get(): Promise<model.api.getResponse>;
}

export declare namespace NoErrorsService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class NoErrorsService implements NoErrorsService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: NoErrorsService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/\\");
    }

    public async get(): Promise<model.api.getResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.api.getErrorBody
            };
        }
    }
}
",
  "/services/api/index.ts": "export * from \\"./NoErrorsService\\";
",
  "/services/index.ts": "export * as api from \\"./api\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
}
`;

exports[`generateClientProject posts 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/index.ts": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
  "/model/commons/_types/PostId.ts": "/**
 * An ID of a blog post
 */
export type PostId = string;
",
  "/model/commons/_types/index.ts": "export * from \\"./PostId\\";
",
  "/model/commons/index.ts": "export * from \\"./_types\\";
",
  "/model/index.ts": "export * as commons from \\"./commons\\";
export * as posts from \\"./posts\\";
",
  "/model/posts/_errors/PostNotFoundError.ts": "import * as model from \\"../..\\";

export interface PostNotFoundError {
    id: model.commons.PostId;
}
",
  "/model/posts/_errors/index.ts": "export * from \\"./PostNotFoundError\\";
",
  "/model/posts/_service-types/PostsService/createPostErrorBody.ts": "export type createPostErrorBody = never;

export declare namespace createPostErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const createPostErrorBody = {
    _visit: <Result>(_value: createPostErrorBody, visitor: createPostErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): createPostErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/posts/_service-types/PostsService/createPostRequest.ts": "import * as model from \\"../../..\\";

export interface createPostRequest {
    xEndpointHeader: string;
    body: model.posts.CreatePostRequest;
}
",
  "/model/posts/_service-types/PostsService/createPostResponse.ts": "import * as model from \\"../../..\\";

export type createPostResponse = createPostResponse.SuccessResponse | createPostResponse.ErrorResponse;

export declare namespace createPostResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.commons.PostId;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.posts.createPostErrorBody;
    }
}
",
  "/model/posts/_service-types/PostsService/getAllPostsErrorBody.ts": "export type getAllPostsErrorBody = never;

export declare namespace getAllPostsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const getAllPostsErrorBody = {
    _visit: <Result>(_value: getAllPostsErrorBody, visitor: getAllPostsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): getAllPostsErrorBody[\\"_error\\"][] => [],
} as const;
",
  "/model/posts/_service-types/PostsService/getAllPostsResponse.ts": "import * as model from \\"../../..\\";

export type getAllPostsResponse = getAllPostsResponse.SuccessResponse | getAllPostsResponse.ErrorResponse;

export declare namespace getAllPostsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.posts.Post[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.posts.getAllPostsErrorBody;
    }
}
",
  "/model/posts/_service-types/PostsService/getPostErrorBody.ts": "import { posts } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type getPostErrorBody =
    | getPostErrorBody.PostNotFoundError;

export declare namespace getPostErrorBody {
    interface PostNotFoundError extends posts.PostNotFoundError {
        _error: \\"PostNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PostNotFoundError: (value: posts.PostNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const getPostErrorBody = {
    postNotFoundError: (value: posts.PostNotFoundError): getPostErrorBody.PostNotFoundError => ({
        ...value,
        _error: \\"PostNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: getPostErrorBody, visitor: getPostErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PostNotFoundError\\": return visitor.PostNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): getPostErrorBody[\\"_error\\"][] => [\\"PostNotFoundError\\"],
} as const;
",
  "/model/posts/_service-types/PostsService/getPostRequest.ts": "import * as model from \\"../../..\\";

export interface getPostRequest {
    postId: model.commons.PostId;
    page: number | null | undefined;
    otherParam: number;
}
",
  "/model/posts/_service-types/PostsService/getPostResponse.ts": "import * as model from \\"../../..\\";

export type getPostResponse = getPostResponse.SuccessResponse | getPostResponse.ErrorResponse;

export declare namespace getPostResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.posts.Post;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.posts.getPostErrorBody;
    }
}
",
  "/model/posts/_service-types/PostsService/getPostV2ErrorBody.ts": "import { posts } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type getPostV2ErrorBody =
    | getPostV2ErrorBody.PostNotFoundError;

export declare namespace getPostV2ErrorBody {
    interface PostNotFoundError extends posts.PostNotFoundError {
        _error: \\"PostNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PostNotFoundError: (value: posts.PostNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const getPostV2ErrorBody = {
    postNotFoundError: (value: posts.PostNotFoundError): getPostV2ErrorBody.PostNotFoundError => ({
        ...value,
        _error: \\"PostNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: getPostV2ErrorBody, visitor: getPostV2ErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PostNotFoundError\\": return visitor.PostNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): getPostV2ErrorBody[\\"_error\\"][] => [\\"PostNotFoundError\\"],
} as const;
",
  "/model/posts/_service-types/PostsService/getPostV2Response.ts": "import * as model from \\"../../..\\";

export type getPostV2Response = getPostV2Response.SuccessResponse | getPostV2Response.ErrorResponse;

export declare namespace getPostV2Response {
    export interface SuccessResponse {
        ok: true;
        body: model.posts.Post;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.posts.getPostV2ErrorBody;
    }
}
",
  "/model/posts/_service-types/PostsService/index.ts": "export * from \\"./createPostRequest\\";
export * from \\"./createPostErrorBody\\";
export * from \\"./createPostResponse\\";
export * from \\"./getPostRequest\\";
export * from \\"./getPostErrorBody\\";
export * from \\"./getPostResponse\\";
export * from \\"./getPostV2ErrorBody\\";
export * from \\"./getPostV2Response\\";
export * from \\"./getAllPostsErrorBody\\";
export * from \\"./getAllPostsResponse\\";
",
  "/model/posts/_service-types/index.ts": "export * from \\"./PostsService\\";
",
  "/model/posts/_types/Author.ts": "export type Author =
    | Author.Anonymous
    | Author.Named;

export declare namespace Author {
    interface Anonymous {
        _type: \\"anonymous\\";
    }

    interface Named {
        _type: \\"named\\";
        named: string;
    }

    export interface _Visitor<Result> {
        anonymous: () => Result;
        named: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const Author = {
    anonymous: (): Author.Anonymous => ({
        _type: \\"anonymous\\"
    }),

    named: (value: string): Author.Named => ({
        named: value,
        _type: \\"named\\"
    }),

    _visit: <Result>(value: Author, visitor: Author._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"anonymous\\": return visitor.anonymous();
            case \\"named\\": return visitor.named(value.named);
            default: return visitor._unknown();
        }
    },

    _types: (): Author[\\"_type\\"][] => [\\"anonymous\\", \\"named\\"],
} as const;
",
  "/model/posts/_types/CreatePostRequest.ts": "import * as model from \\"../..\\";

export interface CreatePostRequest {
    type: model.posts.PostType;
    title: string;
    author: model.posts.Author;
    content: string;
}
",
  "/model/posts/_types/Post.ts": "import * as model from \\"../..\\";

/**
 * A blog post
 */
export interface Post {
    id: model.commons.PostId;
    type: model.posts.PostType;
    title: string;
    author: model.posts.Author;
    content: string;
    relatedPosts: model.posts.Post[];
}
",
  "/model/posts/_types/PostType.ts": "export type PostType =
    | \\"LONG\\"
    | \\"SHORT\\";

export const PostType = {
    Long: \\"LONG\\",
    Short: \\"SHORT\\",

    _visit: <Result>(value: PostType, visitor: PostType._Visitor<Result>): Result => {
        switch (value) {
            case PostType.Long: return visitor.long();
            case PostType.Short: return visitor.short();
            default: return visitor._unknown();
        }
    },

    _values: (): PostType[] => [PostType.Long, PostType.Short],
} as const;

export declare namespace PostType {
    type Long = \\"LONG\\";
    type Short = \\"SHORT\\";

    export interface _Visitor<Result> {
        long: () => Result;
        short: () => Result;
        _unknown: () => Result;
    }
}
",
  "/model/posts/_types/index.ts": "export * from \\"./Post\\";
export * from \\"./PostType\\";
export * from \\"./Author\\";
export * from \\"./CreatePostRequest\\";
",
  "/model/posts/index.ts": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"@fern-typescript/service-utils\\": \\"0.0.184\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/services/index.ts": "export * as posts from \\"./posts\\";
",
  "/services/posts/PostsService.ts": "import { isResponseOk, Supplier, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface PostsService {
    createPost(request: model.posts.createPostRequest): Promise<model.posts.createPostResponse>;
    getPost(request: model.posts.getPostRequest): Promise<model.posts.getPostResponse>;
    getPostV2(request: model.commons.PostId): Promise<model.posts.getPostV2Response>;
    getAllPosts(): Promise<model.posts.getAllPostsResponse>;
}

export declare namespace PostsService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
        headers: Headers;
    }

    interface Headers {
        xServiceHeader: Supplier<string>;
    }
}

export class PostsService implements PostsService {
    private baseUrl: string;
    private fetcher: Fetcher;
    private headers: PostsService.Headers;

    constructor(args: PostsService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/posts\\");
        this.headers = args.headers;
    }

    public async createPost(request: model.posts.createPostRequest): Promise<model.posts.createPostResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"POST\\",
            headers: {
                \\"X-Service-Header\\": await Supplier.get(this.headers[\\"xServiceHeader\\"]),
                \\"X-Endpoint-Header\\": request[\\"xEndpointHeader\\"]
            },
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.commons.PostId
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.posts.createPostErrorBody
            };
        }
    }

    public async getPost(request: model.posts.getPostRequest): Promise<model.posts.getPostResponse> {
        const queryParameters = new URLSearchParams();
        if (request.page != null) {
            queryParameters.append(\\"page\\", request.page.toString());
        }
        queryParameters.append(\\"otherParam\\", request.otherParam.toString());

        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.postId}\`),
            method: \\"GET\\",
            headers: {
                \\"X-Service-Header\\": await Supplier.get(this.headers[\\"xServiceHeader\\"])
            },
            queryParameters
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.posts.Post
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.posts.getPostErrorBody
            };
        }
    }

    public async getPostV2(request: model.commons.PostId): Promise<model.posts.getPostV2Response> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/get\\"),
            method: \\"GET\\",
            headers: {
                \\"X-Service-Header\\": await Supplier.get(this.headers[\\"xServiceHeader\\"])
            },
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.posts.Post
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.posts.getPostV2ErrorBody
            };
        }
    }

    public async getAllPosts(): Promise<model.posts.getAllPostsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/get-all\\"),
            method: \\"GET\\",
            headers: {
                \\"X-Service-Header\\": await Supplier.get(this.headers[\\"xServiceHeader\\"])
            }
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.posts.Post[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.posts.getAllPostsErrorBody
            };
        }
    }
}
",
  "/services/posts/index.ts": "export * from \\"./PostsService\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
}
`;
