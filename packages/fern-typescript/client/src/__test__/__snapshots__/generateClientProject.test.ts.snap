// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateClientProject chat app 1`] = `
Object {
  "/package.json": "{
    \\"name\\": \\"chat\\",
    \\"version\\": \\"0.0.0\\",
    \\"files\\": [
        \\"lib\\"
    ],
    \\"main\\": \\"./lib/cjs/index.js\\",
    \\"types\\": \\"./lib/cjs/index.d.ts\\",
    \\"exports\\": {
        \\".\\": {
            \\"require\\": \\"./lib/cjs/index.js\\",
            \\"default\\": \\"./lib/esm/index.js\\"
        }
    },
    \\"sideEffects\\": false,
    \\"scripts\\": {
        \\"build\\": \\"run-p build:esm build:cjs\\",
        \\"build:esm\\": \\"tsc --project tsconfig.esm.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"module\\\\\\" }' > lib/esm/package.json\\",
        \\"build:cjs\\": \\"tsc --project tsconfig.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"commonjs\\\\\\" }' > lib/cjs/package.json\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"^8.3.2\\"
    },
    \\"devDependencies\\": {
        \\"@types/uuid\\": \\"^8.3.4\\",
        \\"@types/node\\": \\"^17.0.33\\",
        \\"npm-run-all\\": \\"^4.1.5\\",
        \\"typescript\\": \\"^4.6.4\\"
    }
}",
  "/src/index.ts": "export * from \\"./model\\";
export * from \\"./services\\";
",
  "/src/model/chat/errors/GenericMessage.ts": "export type GenericMessage = string & {
    __GenericMessage: void;
};

export const GenericMessage = {
    of: (value: string): GenericMessage => value as GenericMessage
};
",
  "/src/model/chat/errors/index.ts": "export * from \\"./GenericMessage\\";
",
  "/src/model/chat/index.ts": "export * from \\"./errors\\";
export * from \\"./service-types\\";
export * from \\"./types\\";
",
  "/src/model/chat/service-types/ChatService/SendChatErrorBody.ts.ts": "import * as model from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type SendChatErrorBody =
    | SendChatErrorBody.GenericMessage;

export declare namespace SendChatErrorBody {
    interface GenericMessage {
        _error: \\"GenericMessage\\";
        _errorInstanceId: string;
        GenericMessage: model.GenericMessage;
    }

    export interface _Visitor<Result> {
        GenericMessage: (value: model.GenericMessage) => Result;
        _unknown: () => Result;
    }
}

export const SendChatErrorBody = {
    GenericMessage: (value: model.GenericMessage): SendChatErrorBody.GenericMessage => ({
        GenericMessage: value,
        _error: \\"GenericMessage\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: SendChatErrorBody, visitor: SendChatErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"GenericMessage\\": return visitor.GenericMessage(value.GenericMessage);
            default: return visitor._unknown();
        }
    },

    _types: (): SendChatErrorBody[\\"_error\\"][] => [\\"GenericMessage\\"],
} as const;
",
  "/src/model/chat/service-types/ChatService/SendChatRequest.ts.ts": "import { SendChatRequestBody } from \\"./SendChatRequestBody.ts\\";

export interface SendChatRequest {
    id: string;
    operation: \\"sendChat\\";
    body: SendChatRequestBody;
}
",
  "/src/model/chat/service-types/ChatService/SendChatRequestBody.ts.ts": "export interface SendChatRequestBody {
    title: string;
    content: string;
}
",
  "/src/model/chat/service-types/ChatService/SendChatResponse.ts.ts": "import { ChatMessage } from \\"../../types/ChatMessage\\";
import { SendChatErrorBody } from \\"./SendChatErrorBody.ts\\";

export type SendChatResponse = SendChatResponse.SuccessResponse | SendChatResponse.ErrorResponse;

namespace SendChatResponse {
    export interface SuccessResponse {
        ok: true;
        id: string;
        replyTo: string;
        body: ChatMessage;
    }

    export interface ErrorResponse {
        ok: false;
        id: string;
        replyTo: string;
        error: SendChatErrorBody;
    }
}
",
  "/src/model/chat/service-types/ChatService/index.ts": "export * from \\"./SendChatErrorBody.ts\\";
export * from \\"./SendChatRequest.ts\\";
export * from \\"./SendChatRequestBody.ts\\";
export * from \\"./SendChatResponse.ts\\";
",
  "/src/model/chat/service-types/index.ts": "export * from \\"./ChatService\\";
",
  "/src/model/chat/types/ChatMessage.ts": "import { ChatMessageId } from \\"./ChatMessageId\\";

export interface ChatMessage {
    id: ChatMessageId;
    title: string;
    content: string;
}
",
  "/src/model/chat/types/ChatMessageId.ts": "export type ChatMessageId = string & {
    __ChatMessageId: void;
};

export const ChatMessageId = {
    of: (value: string): ChatMessageId => value as ChatMessageId
};
",
  "/src/model/chat/types/index.ts": "export * from \\"./ChatMessage\\";
export * from \\"./ChatMessageId\\";
",
  "/src/model/index.ts": "export * from \\"./chat\\";
",
  "/src/services/ChatService/ChatService.ts": "import path from \\"path\\";
import * as model from \\"../../model\\";
import * as uuid from \\"uuid\\";

export declare namespace Client {
    interface Args {
        origin: string;
    }

    type ServerMessage = model.SendChatResponse;
}

export interface Client {
    sendChat(request: model.SendChatRequestBody): Promise<model.SendChatResponse>;
}

export class Client implements Client {
    private socket: Promise<WebSocket>;
    private callbacks: Record<string, (response: any) => void> = {};

    constructor(args: Client.Args) {
        this.socket = new Promise(resolve => {
            const socket = new WebSocket(path.join(args.origin, \\"/chat\\"));
            socket.onopen = () => {
                resolve(socket);
            };
            socket.onmessage = this._onMessage;
        });
    }

    public async sendChat(request: model.SendChatRequestBody): Promise<model.SendChatResponse> {
        const socket = await this.socket;

        return new Promise(resolve => {
            const message: model.SendChatRequest = {
                id: uuid.v4(),
                operation: \\"sendChat\\",
                body: request
            };
            this.callbacks[message.id] = resolve;
            socket.send(JSON.stringify(message));
        });
    }

    public async _disconnect(): Promise<void> {
        const socket = await this.socket;
        return new Promise(resolve => {
            socket.onclose = () => {
                resolve();
            };
            socket.close();
        });
    }

    private _onMessage(event: MessageEvent): void {
        const message = JSON.parse(event.data) as Client.ServerMessage;
        if (\\"operation\\" in message) {
            console.log(\\"Received server message\\");
        }
        else {
            const callback = this.callbacks[message.replyTo];
            if (callback != null) {
                callback(message);
            }
            else {
                console.error(\\"Received reply to unknown request\\");
            }
        }
    }
}
",
  "/src/services/ChatService/index.ts": "export * from \\"./ChatService\\";
",
  "/src/services/index.ts": "export * as ChatService from \\"./ChatService\\";
",
  "/tsconfig.esm.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"esnext\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/esm\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"commonjs\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/cjs\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
}
`;

exports[`generateClientProject no errors 1`] = `
Object {
  "/package.json": "{
    \\"name\\": \\"no-errors\\",
    \\"version\\": \\"0.0.0\\",
    \\"files\\": [
        \\"lib\\"
    ],
    \\"main\\": \\"./lib/cjs/index.js\\",
    \\"types\\": \\"./lib/cjs/index.d.ts\\",
    \\"exports\\": {
        \\".\\": {
            \\"require\\": \\"./lib/cjs/index.js\\",
            \\"default\\": \\"./lib/esm/index.js\\"
        }
    },
    \\"sideEffects\\": false,
    \\"scripts\\": {
        \\"build\\": \\"run-p build:esm build:cjs\\",
        \\"build:esm\\": \\"tsc --project tsconfig.esm.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"module\\\\\\" }' > lib/esm/package.json\\",
        \\"build:cjs\\": \\"tsc --project tsconfig.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"commonjs\\\\\\" }' > lib/cjs/package.json\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.86\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"^17.0.33\\",
        \\"npm-run-all\\": \\"^4.1.5\\",
        \\"typescript\\": \\"^4.6.4\\"
    }
}",
  "/src/index.ts": "export * from \\"./model\\";
export * from \\"./services\\";
",
  "/src/model/api/index.ts": "export * from \\"./service-types\\";
",
  "/src/model/api/service-types/NoErrorsService/GetResponse.ts.ts": "export type GetResponse = GetResponse.SuccessResponse | GetResponse.ErrorResponse;

namespace GetResponse {
    export interface SuccessResponse {
        ok: true;
        statusCode: number;
    }

    export interface ErrorResponse {
        ok: false;
        statusCode: number;
    }
}
",
  "/src/model/api/service-types/NoErrorsService/index.ts": "export * from \\"./GetResponse.ts\\";
",
  "/src/model/api/service-types/index.ts": "export * from \\"./NoErrorsService\\";
",
  "/src/model/index.ts": "export * from \\"./api\\";
",
  "/src/services/NoErrorsService/NoErrorsService.ts": "import { Fetcher, defaultFetcher, Service, isResponseOk, Token } from \\"@fern-typescript/service-utils\\";
import * as model from \\"../../model\\";
import path from \\"path\\";

export interface Client {
    get(): Promise<model.GetResponse>;
}

export class Client implements Client {
    private baseUrl: string;
    private fetcher: Fetcher;
    private token: Token | undefined;

    constructor(args: Service.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = args.origin;
        this.token = args.token;
    }

    public async get(): Promise<model.GetResponse> {
        const encodedResponse = await this.fetcher({
            url: path.join(this.baseUrl, \\"/\\"),
            method: \\"GET\\",
            headers: {},
            token: this.token
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                statusCode: encodedResponse.statusCode
            };
        }
        else {
            return {
                ok: false,
                statusCode: encodedResponse.statusCode
            };
        }
    }
}
",
  "/src/services/NoErrorsService/index.ts": "export * from \\"./NoErrorsService\\";
",
  "/src/services/index.ts": "export * as NoErrorsService from \\"./NoErrorsService\\";
",
  "/tsconfig.esm.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"esnext\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/esm\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"commonjs\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/cjs\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
}
`;

exports[`generateClientProject posts 1`] = `
Object {
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"files\\": [
        \\"lib\\"
    ],
    \\"main\\": \\"./lib/cjs/index.js\\",
    \\"types\\": \\"./lib/cjs/index.d.ts\\",
    \\"exports\\": {
        \\".\\": {
            \\"require\\": \\"./lib/cjs/index.js\\",
            \\"default\\": \\"./lib/esm/index.js\\"
        }
    },
    \\"sideEffects\\": false,
    \\"scripts\\": {
        \\"build\\": \\"run-p build:esm build:cjs\\",
        \\"build:esm\\": \\"tsc --project tsconfig.esm.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"module\\\\\\" }' > lib/esm/package.json\\",
        \\"build:cjs\\": \\"tsc --project tsconfig.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"commonjs\\\\\\" }' > lib/cjs/package.json\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.86\\",
        \\"uuid\\": \\"^8.3.2\\"
    },
    \\"devDependencies\\": {
        \\"@types/uuid\\": \\"^8.3.4\\",
        \\"@types/node\\": \\"^17.0.33\\",
        \\"npm-run-all\\": \\"^4.1.5\\",
        \\"typescript\\": \\"^4.6.4\\"
    }
}",
  "/src/index.ts": "export * from \\"./model\\";
export * from \\"./services\\";
",
  "/src/model/commons/index.ts": "export * from \\"./types\\";
",
  "/src/model/commons/types/PostId.ts": "/**
 * An ID of a blog post
 */
export type PostId = string & {
    __PostId: void;
};

export const PostId = {
    of: (value: string): PostId => value as PostId
};
",
  "/src/model/commons/types/index.ts": "export * from \\"./PostId\\";
",
  "/src/model/index.ts": "export * from \\"./commons\\";
export * from \\"./posts\\";
",
  "/src/model/posts/errors/PostNotFoundError.ts": "import { PostId } from \\"../../commons/types/PostId\\";

export interface PostNotFoundError {
    id: PostId;
}
",
  "/src/model/posts/errors/index.ts": "export * from \\"./PostNotFoundError\\";
",
  "/src/model/posts/index.ts": "export * from \\"./errors\\";
export * from \\"./service-types\\";
export * from \\"./types\\";
",
  "/src/model/posts/service-types/PostsService/CreatePostRequest.ts.ts": "import { PostType } from \\"../../types/PostType\\";
import { Author } from \\"../../types/Author\\";

export interface CreatePostRequest {
    type: PostType;
    title: string;
    author: Author;
    content: string;
}
",
  "/src/model/posts/service-types/PostsService/CreatePostResponse.ts.ts": "import { PostId } from \\"../../../commons/types/PostId\\";

export type CreatePostResponse = CreatePostResponse.SuccessResponse | CreatePostResponse.ErrorResponse;

namespace CreatePostResponse {
    export interface SuccessResponse {
        ok: true;
        statusCode: number;
        body: PostId;
    }

    export interface ErrorResponse {
        ok: false;
        statusCode: number;
    }
}
",
  "/src/model/posts/service-types/PostsService/GetPostErrorBody.ts.ts": "import * as model from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPostErrorBody =
    | GetPostErrorBody.PostNotFoundError;

export declare namespace GetPostErrorBody {
    interface PostNotFoundError extends model.PostNotFoundError {
        _error: \\"PostNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PostNotFoundError: (value: model.PostNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const GetPostErrorBody = {
    PostNotFoundError: (value: model.PostNotFoundError): GetPostErrorBody.PostNotFoundError => ({
        ...value,
        _error: \\"PostNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPostErrorBody, visitor: GetPostErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PostNotFoundError\\": return visitor.PostNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): GetPostErrorBody[\\"_error\\"][] => [\\"PostNotFoundError\\"],
} as const;
",
  "/src/model/posts/service-types/PostsService/GetPostRequest.ts.ts": "import { PostId } from \\"../../../commons/types/PostId\\";

export interface GetPostRequest {
    postId: PostId;
    page: number | null | undefined;
    otherParam: number | null | undefined;
}
",
  "/src/model/posts/service-types/PostsService/GetPostResponse.ts.ts": "import { Post } from \\"../../types/Post\\";
import { GetPostErrorBody } from \\"./GetPostErrorBody.ts\\";

export type GetPostResponse = GetPostResponse.SuccessResponse | GetPostResponse.ErrorResponse;

namespace GetPostResponse {
    export interface SuccessResponse {
        ok: true;
        statusCode: number;
        body: Post;
    }

    export interface ErrorResponse {
        ok: false;
        statusCode: number;
        error: GetPostErrorBody;
    }
}
",
  "/src/model/posts/service-types/PostsService/GetPostV2ErrorBody.ts.ts": "import * as model from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPostV2ErrorBody =
    | GetPostV2ErrorBody.PostNotFoundError;

export declare namespace GetPostV2ErrorBody {
    interface PostNotFoundError extends model.PostNotFoundError {
        _error: \\"PostNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PostNotFoundError: (value: model.PostNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const GetPostV2ErrorBody = {
    PostNotFoundError: (value: model.PostNotFoundError): GetPostV2ErrorBody.PostNotFoundError => ({
        ...value,
        _error: \\"PostNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPostV2ErrorBody, visitor: GetPostV2ErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PostNotFoundError\\": return visitor.PostNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): GetPostV2ErrorBody[\\"_error\\"][] => [\\"PostNotFoundError\\"],
} as const;
",
  "/src/model/posts/service-types/PostsService/GetPostV2Response.ts.ts": "import { Post } from \\"../../types/Post\\";
import { GetPostV2ErrorBody } from \\"./GetPostV2ErrorBody.ts\\";

export type GetPostV2Response = GetPostV2Response.SuccessResponse | GetPostV2Response.ErrorResponse;

namespace GetPostV2Response {
    export interface SuccessResponse {
        ok: true;
        statusCode: number;
        body: Post;
    }

    export interface ErrorResponse {
        ok: false;
        statusCode: number;
        error: GetPostV2ErrorBody;
    }
}
",
  "/src/model/posts/service-types/PostsService/index.ts": "export * from \\"./CreatePostRequest.ts\\";
export * from \\"./CreatePostResponse.ts\\";
export * from \\"./GetPostErrorBody.ts\\";
export * from \\"./GetPostRequest.ts\\";
export * from \\"./GetPostResponse.ts\\";
export * from \\"./GetPostV2ErrorBody.ts\\";
export * from \\"./GetPostV2Response.ts\\";
",
  "/src/model/posts/service-types/index.ts": "export * from \\"./PostsService\\";
",
  "/src/model/posts/types/Author.ts": "export type Author =
    | Author.Anonymous
    | Author.Named;

export declare namespace Author {
    interface Anonymous {
        _type: \\"anonymous\\";
    }

    interface Named {
        _type: \\"named\\";
        named: string;
    }

    export interface _Visitor<Result> {
        anonymous: () => Result;
        named: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const Author = {
    anonymous: (): Author.Anonymous => ({
        _type: \\"anonymous\\"
    }),

    named: (value: string): Author.Named => ({
        named: value,
        _type: \\"named\\"
    }),

    _visit: <Result>(value: Author, visitor: Author._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"anonymous\\": return visitor.anonymous();
            case \\"named\\": return visitor.named(value.named);
            default: return visitor._unknown();
        }
    },

    _types: (): Author[\\"_type\\"][] => [\\"anonymous\\", \\"named\\"],
} as const;
",
  "/src/model/posts/types/Post.ts": "import { PostId } from \\"../../commons/types/PostId\\";
import { PostType } from \\"./PostType\\";
import { Author } from \\"./Author\\";

/**
 * A blog post
 */
export interface Post {
    id: PostId;
    type: PostType;
    title: string;
    author: Author;
    content: string;
    relatedPosts: Post[];
}
",
  "/src/model/posts/types/PostType.ts": "export type PostType =
    | \\"LONG\\"
    | \\"SHORT\\";

export const PostType = {
    Long: \\"LONG\\",
    Short: \\"SHORT\\",

    _visit: <Result>(value: PostType, visitor: PostType._Visitor<Result>): Result => {
        switch (value) {
            case PostType.Long: return visitor.long();
            case PostType.Short: return visitor.short();
            default: return visitor._unknown();
        }
    },

    _values: (): PostType[] => [PostType.Long, PostType.Short],
} as const;

export declare namespace PostType {
    type Long = \\"LONG\\";
    type Short = \\"SHORT\\";

    export interface _Visitor<Result> {
        long: () => Result;
        short: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/model/posts/types/index.ts": "export * from \\"./Author\\";
export * from \\"./Post\\";
export * from \\"./PostType\\";
",
  "/src/services/PostsService/PostsService.ts": "import { Fetcher, defaultFetcher, Service, isResponseOk, Token } from \\"@fern-typescript/service-utils\\";
import path from \\"path\\";
import * as model from \\"../../model\\";

export interface Client {
    createPost(request: model.CreatePostRequest): Promise<model.CreatePostResponse>;
    getPost(request: model.GetPostRequest): Promise<model.GetPostResponse>;
    getPostV2(request: model.PostId): Promise<model.GetPostV2Response>;
}

export class Client implements Client {
    private baseUrl: string;
    private fetcher: Fetcher;
    private token: Token | undefined;

    constructor(args: Service.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = path.join(args.origin, \\"/posts\\");
        this.token = args.token;
    }

    public async createPost(request: model.CreatePostRequest): Promise<model.CreatePostResponse> {
        const encodedResponse = await this.fetcher({
            url: path.join(this.baseUrl, \\"/\\"),
            method: \\"POST\\",
            headers: {},
            token: this.token,
            body: {
                content: JSON.stringify(request),
                contentType: \\"application/json\\"
            }
        });

        if (isResponseOk(encodedResponse)) {
            const response = JSON.parse(new TextDecoder().decode(encodedResponse.body));
            return {
                ok: true,
                statusCode: encodedResponse.statusCode,
                body: response as model.PostId
            };
        }
        else {
            return {
                ok: false,
                statusCode: encodedResponse.statusCode
            };
        }
    }

    public async getPost(request: model.GetPostRequest): Promise<model.GetPostResponse> {
        const queryParameters = new URLSearchParams();
        if (request.page != null) {
            queryParameters.append(\\"page\\", request.page.toString());
        }
        if (request.otherParam != null) {
            queryParameters.append(\\"otherParam\\", request.otherParam.toString());
        }

        const encodedResponse = await this.fetcher({
            url: path.join(this.baseUrl, \`/\${request.postId}\`),
            method: \\"GET\\",
            headers: {},
            token: this.token,
            queryParameters
        });

        if (isResponseOk(encodedResponse)) {
            const response = JSON.parse(new TextDecoder().decode(encodedResponse.body));
            return {
                ok: true,
                statusCode: encodedResponse.statusCode,
                body: response as model.Post
            };
        }
        else {
            const error = JSON.parse(new TextDecoder().decode(encodedResponse.body));
            return {
                ok: false,
                statusCode: encodedResponse.statusCode,
                error: error as model.GetPostErrorBody
            };
        }
    }

    public async getPostV2(request: model.PostId): Promise<model.GetPostV2Response> {
        const encodedResponse = await this.fetcher({
            url: path.join(this.baseUrl, \\"/get\\"),
            method: \\"GET\\",
            headers: {},
            token: this.token,
            body: {
                content: JSON.stringify(request),
                contentType: \\"application/json\\"
            }
        });

        if (isResponseOk(encodedResponse)) {
            const response = JSON.parse(new TextDecoder().decode(encodedResponse.body));
            return {
                ok: true,
                statusCode: encodedResponse.statusCode,
                body: response as model.Post
            };
        }
        else {
            const error = JSON.parse(new TextDecoder().decode(encodedResponse.body));
            return {
                ok: false,
                statusCode: encodedResponse.statusCode,
                error: error as model.GetPostV2ErrorBody
            };
        }
    }
}
",
  "/src/services/PostsService/index.ts": "export * from \\"./PostsService\\";
",
  "/src/services/index.ts": "export * as PostsService from \\"./PostsService\\";
",
  "/tsconfig.esm.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"esnext\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/esm\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"commonjs\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/cjs\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
}
`;
