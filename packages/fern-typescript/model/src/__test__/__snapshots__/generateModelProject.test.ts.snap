// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateModelProject fern IR 1`] = `
Object {
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"files\\": [
        \\"lib\\"
    ],
    \\"main\\": \\"./lib/cjs/index.js\\",
    \\"types\\": \\"./lib/cjs/index.d.ts\\",
    \\"exports\\": {
        \\".\\": {
            \\"require\\": \\"./lib/cjs/index.js\\",
            \\"default\\": \\"./lib/esm/index.js\\"
        }
    },
    \\"sideEffects\\": false,
    \\"scripts\\": {
        \\"build\\": \\"run-p build:esm build:cjs\\",
        \\"build:esm\\": \\"tsc --project tsconfig.esm.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"module\\\\\\" }' > lib/esm/package.json\\",
        \\"build:cjs\\": \\"tsc --project tsconfig.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"commonjs\\\\\\" }' > lib/cjs/package.json\\"
    },
    \\"dependencies\\": {},
    \\"devDependencies\\": {
        \\"@types/node\\": \\"^17.0.33\\",
        \\"npm-run-all\\": \\"^4.1.5\\",
        \\"typescript\\": \\"^4.6.4\\"
    }
}",
  "/src/index.ts": "export * from \\"./model\\";
",
  "/src/model/commons/index.ts": "export * from \\"./types\\";
",
  "/src/model/commons/types/WithDocs.ts": "export interface WithDocs {
    docs: string | null | undefined;
}
",
  "/src/model/commons/types/index.ts": "export * from \\"./WithDocs\\";
",
  "/src/model/errors/index.ts": "export * from \\"./types\\";
",
  "/src/model/errors/types/ErrorDefinition.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";
import { NamedType } from \\"../../types/types/NamedType\\";
import { ErrorProperty } from \\"./ErrorProperty\\";
import { HttpErrorConfiguration } from \\"./HttpErrorConfiguration\\";

export interface ErrorDefinition extends WithDocs {
    name: NamedType;
    properties: ErrorProperty[];
    http: HttpErrorConfiguration | null | undefined;
}
",
  "/src/model/errors/types/ErrorProperty.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";
import { TypeReference } from \\"../../types/types/TypeReference\\";

export interface ErrorProperty extends WithDocs {
    name: string;
    type: TypeReference;
}
",
  "/src/model/errors/types/HttpErrorConfiguration.ts": "export interface HttpErrorConfiguration {
    statusCode: number;
}
",
  "/src/model/errors/types/index.ts": "export * from \\"./ErrorDefinition\\";
export * from \\"./ErrorProperty\\";
export * from \\"./HttpErrorConfiguration\\";
",
  "/src/model/fern/index.ts": "export * from \\"./types\\";
",
  "/src/model/fern/types/IntermediateRepresentation.ts": "import { TypeDefinition } from \\"../../types/types/TypeDefinition\\";
import { Services } from \\"./Services\\";
import { ErrorDefinition } from \\"../../errors/types/ErrorDefinition\\";

/**
 * Complete representation of the API schema
 */
export interface IntermediateRepresentation {
    /** The types described by this API */
    types: TypeDefinition[];
    /** The services exposed by this API */
    services: Services;
    errors: ErrorDefinition[];
}
",
  "/src/model/fern/types/Services.ts": "import { HttpService } from \\"../../services/http/types/HttpService\\";
import { WebSocketService } from \\"../../services/websocket/types/WebSocketService\\";

export interface Services {
    http: HttpService[];
    websocket: WebSocketService[];
}
",
  "/src/model/fern/types/index.ts": "export * from \\"./IntermediateRepresentation\\";
export * from \\"./Services\\";
",
  "/src/model/index.ts": "export * from \\"./commons\\";
export * from \\"./errors\\";
export * from \\"./fern\\";
export * from \\"./services\\";
export * from \\"./types\\";
",
  "/src/model/services/commons/index.ts": "export * from \\"./types\\";
",
  "/src/model/services/commons/types/BaseService.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { NamedType } from \\"../../../types/types/NamedType\\";

export interface BaseService extends WithDocs {
    basePath: string;
    name: NamedType;
}
",
  "/src/model/services/commons/types/ResponseError.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { NamedType } from \\"../../../types/types/NamedType\\";

export interface ResponseError extends WithDocs {
    discriminantValue: string;
    error: NamedType;
}
",
  "/src/model/services/commons/types/ResponseErrors.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { ResponseError } from \\"./ResponseError\\";

export interface ResponseErrors extends WithDocs {
    discriminant: string;
    possibleErrors: ResponseError[];
}
",
  "/src/model/services/commons/types/WireMessage.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { Type } from \\"../../../types/types/Type\\";

export interface WireMessage extends WithDocs {
    type: Type;
}
",
  "/src/model/services/commons/types/index.ts": "export * from \\"./BaseService\\";
export * from \\"./ResponseError\\";
export * from \\"./ResponseErrors\\";
export * from \\"./WireMessage\\";
",
  "/src/model/services/http/index.ts": "export * from \\"./types\\";
",
  "/src/model/services/http/types/HttpEndpoint.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { HttpMethod } from \\"./HttpMethod\\";
import { HttpHeader } from \\"./HttpHeader\\";
import { PathParameter } from \\"./PathParameter\\";
import { QueryParameter } from \\"./QueryParameter\\";
import { WireMessage } from \\"../../commons/types/WireMessage\\";
import { ResponseErrors } from \\"../../commons/types/ResponseErrors\\";

export interface HttpEndpoint extends WithDocs {
    endpointId: string;
    path: string;
    method: HttpMethod;
    headers: HttpHeader[];
    parameters: PathParameter[];
    queryParameters: QueryParameter[];
    request: WireMessage | null | undefined;
    response: WireMessage | null | undefined;
    errors: ResponseErrors;
}
",
  "/src/model/services/http/types/HttpHeader.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { TypeReference } from \\"../../../types/types/TypeReference\\";

export interface HttpHeader extends WithDocs {
    header: string;
    valueType: TypeReference;
}
",
  "/src/model/services/http/types/HttpMethod.ts": "export type HttpMethod =
    | \\"GET\\"
    | \\"POST\\"
    | \\"PUT\\"
    | \\"PATCH\\"
    | \\"DELETE\\";

export const HttpMethod = {
    Get: \\"GET\\",
    Post: \\"POST\\",
    Put: \\"PUT\\",
    Patch: \\"PATCH\\",
    Delete: \\"DELETE\\",

    _visit: <Result>(value: HttpMethod, visitor: HttpMethod._Visitor<Result>): Result => {
        switch (value) {
            case HttpMethod.Get: return visitor.get();
            case HttpMethod.Post: return visitor.post();
            case HttpMethod.Put: return visitor.put();
            case HttpMethod.Patch: return visitor.patch();
            case HttpMethod.Delete: return visitor.delete();
            default: return visitor._unknown();
        }
    },

    _values: (): HttpMethod[] => [HttpMethod.Get, HttpMethod.Post, HttpMethod.Put, HttpMethod.Patch, HttpMethod.Delete],
} as const;

export declare namespace HttpMethod {
    type Get = \\"GET\\";
    type Post = \\"POST\\";
    type Put = \\"PUT\\";
    type Patch = \\"PATCH\\";
    type Delete = \\"DELETE\\";

    export interface _Visitor<Result> {
        get: () => Result;
        post: () => Result;
        put: () => Result;
        patch: () => Result;
        delete: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/model/services/http/types/HttpService.ts": "import { BaseService } from \\"../../commons/types/BaseService\\";
import { HttpEndpoint } from \\"./HttpEndpoint\\";
import { HttpHeader } from \\"./HttpHeader\\";

export interface HttpService extends BaseService {
    endpoints: HttpEndpoint[];
    headers: HttpHeader[];
}
",
  "/src/model/services/http/types/PathParameter.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { TypeReference } from \\"../../../types/types/TypeReference\\";

export interface PathParameter extends WithDocs {
    key: string;
    valueType: TypeReference;
}
",
  "/src/model/services/http/types/QueryParameter.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { TypeReference } from \\"../../../types/types/TypeReference\\";

export interface QueryParameter extends WithDocs {
    key: string;
    valueType: TypeReference;
}
",
  "/src/model/services/http/types/index.ts": "export * from \\"./HttpEndpoint\\";
export * from \\"./HttpHeader\\";
export * from \\"./HttpMethod\\";
export * from \\"./HttpService\\";
export * from \\"./PathParameter\\";
export * from \\"./QueryParameter\\";
",
  "/src/model/services/index.ts": "export * from \\"./commons\\";
export * from \\"./http\\";
export * from \\"./websocket\\";
",
  "/src/model/services/websocket/index.ts": "export * from \\"./types\\";
",
  "/src/model/services/websocket/types/WebSocketMessage.ts": "import { WithDocs } from \\"../../../commons/types/WithDocs\\";
import { WebSocketMessageOrigin } from \\"./WebSocketMessageOrigin\\";
import { WireMessage } from \\"../../commons/types/WireMessage\\";
import { WebSocketMessageResponse } from \\"./WebSocketMessageResponse\\";
import { ResponseErrors } from \\"../../commons/types/ResponseErrors\\";

export interface WebSocketMessage extends WithDocs {
    origin: WebSocketMessageOrigin;
    body: WireMessage | null | undefined;
    response: WebSocketMessageResponse | null | undefined;
    errors: ResponseErrors;
}
",
  "/src/model/services/websocket/types/WebSocketMessageOrigin.ts": "export type WebSocketMessageOrigin =
    | \\"CLIENT\\"
    | \\"SERVER\\";

export const WebSocketMessageOrigin = {
    Client: \\"CLIENT\\",
    Server: \\"SERVER\\",

    _visit: <Result>(value: WebSocketMessageOrigin, visitor: WebSocketMessageOrigin._Visitor<Result>): Result => {
        switch (value) {
            case WebSocketMessageOrigin.Client: return visitor.client();
            case WebSocketMessageOrigin.Server: return visitor.server();
            default: return visitor._unknown();
        }
    },

    _values: (): WebSocketMessageOrigin[] => [WebSocketMessageOrigin.Client, WebSocketMessageOrigin.Server],
} as const;

export declare namespace WebSocketMessageOrigin {
    type Client = \\"CLIENT\\";
    type Server = \\"SERVER\\";

    export interface _Visitor<Result> {
        client: () => Result;
        server: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/model/services/websocket/types/WebSocketMessageResponse.ts": "import { WireMessage } from \\"../../commons/types/WireMessage\\";
import { WebSocketMessageResponseBehavior } from \\"./WebSocketMessageResponseBehavior\\";
import { Type } from \\"../../../types/types/Type\\";

export interface WebSocketMessageResponse extends WireMessage {
    /** Defaults to WebSocketMessageResponseBehavior.ONGOING */
    behavior: WebSocketMessageResponseBehavior;
    type: Type;
}
",
  "/src/model/services/websocket/types/WebSocketMessageResponseBehavior.ts": "export type WebSocketMessageResponseBehavior =
    | \\"ONGOING\\"
    | \\"REQUEST_RESPONSE\\";

export const WebSocketMessageResponseBehavior = {
    Ongoing: \\"ONGOING\\",
    RequestResponse: \\"REQUEST_RESPONSE\\",

    _visit: <Result>(value: WebSocketMessageResponseBehavior, visitor: WebSocketMessageResponseBehavior._Visitor<Result>): Result => {
        switch (value) {
            case WebSocketMessageResponseBehavior.Ongoing: return visitor.ongoing();
            case WebSocketMessageResponseBehavior.RequestResponse: return visitor.requestResponse();
            default: return visitor._unknown();
        }
    },

    _values: (): WebSocketMessageResponseBehavior[] => [WebSocketMessageResponseBehavior.Ongoing, WebSocketMessageResponseBehavior.RequestResponse],
} as const;

export declare namespace WebSocketMessageResponseBehavior {
    type Ongoing = \\"ONGOING\\";
    type RequestResponse = \\"REQUEST_RESPONSE\\";

    export interface _Visitor<Result> {
        ongoing: () => Result;
        requestResponse: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/model/services/websocket/types/WebSocketService.ts": "import { BaseService } from \\"../../commons/types/BaseService\\";
import { WebSocketMessage } from \\"./WebSocketMessage\\";

export interface WebSocketService extends BaseService {
    messages: WebSocketMessage[];
}
",
  "/src/model/services/websocket/types/index.ts": "export * from \\"./WebSocketMessage\\";
export * from \\"./WebSocketMessageOrigin\\";
export * from \\"./WebSocketMessageResponse\\";
export * from \\"./WebSocketMessageResponseBehavior\\";
export * from \\"./WebSocketService\\";
",
  "/src/model/types/index.ts": "export * from \\"./types\\";
",
  "/src/model/types/types/AliasTypeDefinition.ts": "import { TypeReference } from \\"./TypeReference\\";

export interface AliasTypeDefinition {
    aliasOf: TypeReference;
}
",
  "/src/model/types/types/ContainerType.ts": "import * as model from \\"../..\\";

export type ContainerType =
    | ContainerType.List
    | ContainerType.Map
    | ContainerType.Optional
    | ContainerType.Set;

export declare namespace ContainerType {
    interface List {
        _type: \\"list\\";
        list: model.TypeReference;
    }

    interface Map extends model.MapType {
        _type: \\"map\\";
    }

    interface Optional {
        _type: \\"optional\\";
        optional: model.TypeReference;
    }

    interface Set {
        _type: \\"set\\";
        set: model.TypeReference;
    }

    export interface _Visitor<Result> {
        list: (value: model.TypeReference) => Result;
        map: (value: model.MapType) => Result;
        optional: (value: model.TypeReference) => Result;
        set: (value: model.TypeReference) => Result;
        _unknown: () => Result;
    }
}

export const ContainerType = {
    list: (value: model.TypeReference): ContainerType.List => ({
        list: value,
        _type: \\"list\\"
    }),

    map: (value: model.MapType): ContainerType.Map => ({
        ...value,
        _type: \\"map\\"
    }),

    optional: (value: model.TypeReference): ContainerType.Optional => ({
        optional: value,
        _type: \\"optional\\"
    }),

    set: (value: model.TypeReference): ContainerType.Set => ({
        set: value,
        _type: \\"set\\"
    }),

    _visit: <Result>(value: ContainerType, visitor: ContainerType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"list\\": return visitor.list(value.list);
            case \\"map\\": return visitor.map(value);
            case \\"optional\\": return visitor.optional(value.optional);
            case \\"set\\": return visitor.set(value.set);
            default: return visitor._unknown();
        }
    },

    _types: (): ContainerType[\\"_type\\"][] => [\\"list\\", \\"map\\", \\"optional\\", \\"set\\"],
} as const;
",
  "/src/model/types/types/EnumTypeDefinition.ts": "import { EnumValue } from \\"./EnumValue\\";

export interface EnumTypeDefinition {
    values: EnumValue[];
}
",
  "/src/model/types/types/EnumValue.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";

export interface EnumValue extends WithDocs {
    value: string;
}
",
  "/src/model/types/types/FernFilepath.ts": "/**
 * A filepath to a Fern spec file, excluding the file extension
 */
export type FernFilepath = string & {
    __FernFilepath: void;
};

export const FernFilepath = {
    of: (value: string): FernFilepath => value as FernFilepath
};
",
  "/src/model/types/types/MapType.ts": "import { TypeReference } from \\"./TypeReference\\";

export interface MapType {
    keyType: TypeReference;
    valueType: TypeReference;
}
",
  "/src/model/types/types/NamedType.ts": "import { FernFilepath } from \\"./FernFilepath\\";

export interface NamedType {
    fernFilepath: FernFilepath;
    name: string;
}
",
  "/src/model/types/types/ObjectProperty.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";
import { TypeReference } from \\"./TypeReference\\";

export interface ObjectProperty extends WithDocs {
    key: string;
    valueType: TypeReference;
}
",
  "/src/model/types/types/ObjectTypeDefinition.ts": "import { NamedType } from \\"./NamedType\\";
import { ObjectProperty } from \\"./ObjectProperty\\";

export interface ObjectTypeDefinition {
    /** A list of other types to inherit from */
    extends: NamedType[];
    properties: ObjectProperty[];
}
",
  "/src/model/types/types/PrimitiveType.ts": "export type PrimitiveType =
    | \\"INTEGER\\"
    | \\"DOUBLE\\"
    | \\"STRING\\"
    | \\"BOOLEAN\\"
    /**
     * Within the range -2^53 to 2^53 */
    | \\"LONG\\";

export const PrimitiveType = {
    Integer: \\"INTEGER\\",
    Double: \\"DOUBLE\\",
    String: \\"STRING\\",
    Boolean: \\"BOOLEAN\\",
    Long: \\"LONG\\",

    _visit: <Result>(value: PrimitiveType, visitor: PrimitiveType._Visitor<Result>): Result => {
        switch (value) {
            case PrimitiveType.Integer: return visitor.integer();
            case PrimitiveType.Double: return visitor.double();
            case PrimitiveType.String: return visitor.string();
            case PrimitiveType.Boolean: return visitor.boolean();
            case PrimitiveType.Long: return visitor.long();
            default: return visitor._unknown();
        }
    },

    _values: (): PrimitiveType[] => [PrimitiveType.Integer, PrimitiveType.Double, PrimitiveType.String, PrimitiveType.Boolean, PrimitiveType.Long],
} as const;

export declare namespace PrimitiveType {
    type Integer = \\"INTEGER\\";
    type Double = \\"DOUBLE\\";
    type String = \\"STRING\\";
    type Boolean = \\"BOOLEAN\\";
    type Long = \\"LONG\\";

    export interface _Visitor<Result> {
        integer: () => Result;
        double: () => Result;
        string: () => Result;
        boolean: () => Result;
        long: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/model/types/types/SingleUnionType.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";
import { TypeReference } from \\"./TypeReference\\";

export interface SingleUnionType extends WithDocs {
    discriminantValue: string;
    valueType: TypeReference;
}
",
  "/src/model/types/types/Type.ts": "import * as model from \\"../..\\";

export type Type =
    | Type.Alias
    | Type.Enum
    | Type.Object
    | Type.Union;

export declare namespace Type {
    interface Alias extends model.AliasTypeDefinition {
        _type: \\"alias\\";
    }

    interface Enum extends model.EnumTypeDefinition {
        _type: \\"enum\\";
    }

    interface Object extends model.ObjectTypeDefinition {
        _type: \\"object\\";
    }

    interface Union extends model.UnionTypeDefinition {
        _type: \\"union\\";
    }

    export interface _Visitor<Result> {
        alias: (value: model.AliasTypeDefinition) => Result;
        enum: (value: model.EnumTypeDefinition) => Result;
        object: (value: model.ObjectTypeDefinition) => Result;
        union: (value: model.UnionTypeDefinition) => Result;
        _unknown: () => Result;
    }
}

export const Type = {
    alias: (value: model.AliasTypeDefinition): Type.Alias => ({
        ...value,
        _type: \\"alias\\"
    }),

    enum: (value: model.EnumTypeDefinition): Type.Enum => ({
        ...value,
        _type: \\"enum\\"
    }),

    object: (value: model.ObjectTypeDefinition): Type.Object => ({
        ...value,
        _type: \\"object\\"
    }),

    union: (value: model.UnionTypeDefinition): Type.Union => ({
        ...value,
        _type: \\"union\\"
    }),

    _visit: <Result>(value: Type, visitor: Type._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"alias\\": return visitor.alias(value);
            case \\"enum\\": return visitor.enum(value);
            case \\"object\\": return visitor.object(value);
            case \\"union\\": return visitor.union(value);
            default: return visitor._unknown();
        }
    },

    _types: (): Type[\\"_type\\"][] => [\\"alias\\", \\"enum\\", \\"object\\", \\"union\\"],
} as const;
",
  "/src/model/types/types/TypeDefinition.ts": "import { WithDocs } from \\"../../commons/types/WithDocs\\";
import { NamedType } from \\"./NamedType\\";
import { Type } from \\"./Type\\";

/**
 * A type, which is a name and a shape
 */
export interface TypeDefinition extends WithDocs {
    name: NamedType;
    shape: Type;
}
",
  "/src/model/types/types/TypeReference.ts": "import * as model from \\"../..\\";

export type TypeReference =
    | TypeReference.Container
    | TypeReference.Named
    | TypeReference.Primitive
    | TypeReference.Void;

export declare namespace TypeReference {
    interface Container {
        _type: \\"container\\";
        container: model.ContainerType;
    }

    interface Named extends model.NamedType {
        _type: \\"named\\";
    }

    interface Primitive {
        _type: \\"primitive\\";
        primitive: model.PrimitiveType;
    }

    interface Void {
        _type: \\"void\\";
    }

    export interface _Visitor<Result> {
        container: (value: model.ContainerType) => Result;
        named: (value: model.NamedType) => Result;
        primitive: (value: model.PrimitiveType) => Result;
        void: () => Result;
        _unknown: () => Result;
    }
}

export const TypeReference = {
    container: (value: model.ContainerType): TypeReference.Container => ({
        container: value,
        _type: \\"container\\"
    }),

    named: (value: model.NamedType): TypeReference.Named => ({
        ...value,
        _type: \\"named\\"
    }),

    primitive: (value: model.PrimitiveType): TypeReference.Primitive => ({
        primitive: value,
        _type: \\"primitive\\"
    }),

    void: (): TypeReference.Void => ({
        _type: \\"void\\"
    }),

    _visit: <Result>(value: TypeReference, visitor: TypeReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"container\\": return visitor.container(value.container);
            case \\"named\\": return visitor.named(value);
            case \\"primitive\\": return visitor.primitive(value.primitive);
            case \\"void\\": return visitor.void();
            default: return visitor._unknown();
        }
    },

    _types: (): TypeReference[\\"_type\\"][] => [\\"container\\", \\"named\\", \\"primitive\\", \\"void\\"],
} as const;
",
  "/src/model/types/types/UnionTypeDefinition.ts": "import { SingleUnionType } from \\"./SingleUnionType\\";

export interface UnionTypeDefinition {
    discriminant: string;
    types: SingleUnionType[];
}
",
  "/src/model/types/types/index.ts": "export * from \\"./AliasTypeDefinition\\";
export * from \\"./ContainerType\\";
export * from \\"./EnumTypeDefinition\\";
export * from \\"./EnumValue\\";
export * from \\"./FernFilepath\\";
export * from \\"./MapType\\";
export * from \\"./NamedType\\";
export * from \\"./ObjectProperty\\";
export * from \\"./ObjectTypeDefinition\\";
export * from \\"./PrimitiveType\\";
export * from \\"./SingleUnionType\\";
export * from \\"./Type\\";
export * from \\"./TypeDefinition\\";
export * from \\"./TypeReference\\";
export * from \\"./UnionTypeDefinition\\";
",
  "/tsconfig.esm.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"esnext\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/esm\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"commonjs\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/cjs\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
}
`;

exports[`generateModelProject posts 1`] = `
Object {
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"files\\": [
        \\"lib\\"
    ],
    \\"main\\": \\"./lib/cjs/index.js\\",
    \\"types\\": \\"./lib/cjs/index.d.ts\\",
    \\"exports\\": {
        \\".\\": {
            \\"require\\": \\"./lib/cjs/index.js\\",
            \\"default\\": \\"./lib/esm/index.js\\"
        }
    },
    \\"sideEffects\\": false,
    \\"scripts\\": {
        \\"build\\": \\"run-p build:esm build:cjs\\",
        \\"build:esm\\": \\"tsc --project tsconfig.esm.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"module\\\\\\" }' > lib/esm/package.json\\",
        \\"build:cjs\\": \\"tsc --project tsconfig.json && echo '{ \\\\\\"type\\\\\\": \\\\\\"commonjs\\\\\\" }' > lib/cjs/package.json\\"
    },
    \\"dependencies\\": {},
    \\"devDependencies\\": {
        \\"@types/node\\": \\"^17.0.33\\",
        \\"npm-run-all\\": \\"^4.1.5\\",
        \\"typescript\\": \\"^4.6.4\\"
    }
}",
  "/src/commons/index.ts": "export * from \\"./types\\";
",
  "/src/commons/types/PostId.ts": "/**
 * An ID of a blog post
 */
export type PostId = string & {
    __PostId: void;
};

export const PostId = {
    of: (value: string): PostId => value as PostId
};
",
  "/src/commons/types/index.ts": "export * from \\"./PostId\\";
",
  "/src/index.ts": "export * as commons from \\"./commons\\";
export * as posts from \\"./posts\\";
",
  "/src/posts/errors/PostNotFoundError.ts": "export type PostNotFoundError = string & {
    __PostNotFoundError: void;
};

export const PostNotFoundError = {
    of: (value: string): PostNotFoundError => value as PostNotFoundError
};
",
  "/src/posts/errors/index.ts": "export * from \\"./PostNotFoundError\\";
",
  "/src/posts/index.ts": "export * from \\"./types\\";
export * from \\"./errors\\";
",
  "/src/posts/types/Author.ts": "export type Author =
    | Author.Anonymous
    | Author.Named;

export declare namespace Author {
    interface Anonymous {
        _type: \\"anonymous\\";
    }

    interface Named {
        _type: \\"named\\";
        named: string;
    }

    export interface _Visitor<Result> {
        anonymous: () => Result;
        named: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const Author = {
    anonymous: (): Author.Anonymous => ({
        _type: \\"anonymous\\"
    }),

    named: (value: string): Author.Named => ({
        named: value,
        _type: \\"named\\"
    }),

    _visit: <Result>(value: Author, visitor: Author._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"anonymous\\": return visitor.anonymous();
            case \\"named\\": return visitor.named(value.named);
            default: return visitor._unknown();
        }
    },

    _types: (): Author[\\"_type\\"][] => [\\"anonymous\\", \\"named\\"],
} as const;
",
  "/src/posts/types/BlogPostReference.ts": "import * as model from \\"../..\\";

export type BlogPostReference =
    | BlogPostReference.Post;

export declare namespace BlogPostReference {
    interface Post extends model.posts.Post {
        _type: \\"post\\";
    }

    export interface _Visitor<Result> {
        post: (value: model.posts.Post) => Result;
        _unknown: () => Result;
    }
}

export const BlogPostReference = {
    post: (value: model.posts.Post): BlogPostReference.Post => ({
        ...value,
        _type: \\"post\\"
    }),

    _visit: <Result>(value: BlogPostReference, visitor: BlogPostReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"post\\": return visitor.post(value);
            default: return visitor._unknown();
        }
    },

    _types: (): BlogPostReference[\\"_type\\"][] => [\\"post\\"],
} as const;
",
  "/src/posts/types/CreatePostRequest.ts": "import { Author } from \\"..\\";

export interface CreatePostRequest {
    title: string;
    author: Author;
    content: string;
}
",
  "/src/posts/types/Post.ts": "import { PostId } from \\"../../commons\\";
import { Author, PostType } from \\"..\\";

/**
 * A blog post
 */
export interface Post {
    id: PostId;
    type: PostType;
    title: string;
    author: Author;
    content: string;
    customConfig: unknown;
}
",
  "/src/posts/types/PostType.ts": "export type PostType =
    | \\"LONG\\"
    | \\"SHORT\\";

export const PostType = {
    Long: \\"LONG\\",
    Short: \\"SHORT\\",

    _visit: <Result>(value: PostType, visitor: PostType._Visitor<Result>): Result => {
        switch (value) {
            case PostType.Long: return visitor.long();
            case PostType.Short: return visitor.short();
            default: return visitor._unknown();
        }
    },

    _values: (): PostType[] => [PostType.Long, PostType.Short],
} as const;

export declare namespace PostType {
    type Long = \\"LONG\\";
    type Short = \\"SHORT\\";

    export interface _Visitor<Result> {
        long: () => Result;
        short: () => Result;
        _unknown: () => Result;
    }
}
",
  "/src/posts/types/index.ts": "export * from \\"./Post\\";
export * from \\"./BlogPostReference\\";
export * from \\"./PostType\\";
export * from \\"./Author\\";
export * from \\"./CreatePostRequest\\";
",
  "/tsconfig.esm.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"esnext\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/esm\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"composite\\": true,
        \\"module\\": \\"commonjs\\",
        \\"target\\": \\"esnext\\",
        \\"outDir\\": \\"lib/cjs\\",
        \\"rootDir\\": \\"src\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"strict\\": true,
        \\"declaration\\": true,
        \\"noFallthroughCasesInSwitch\\": true,
        \\"forceConsistentCasingInFileNames\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    },
    \\"include\\": [
        \\"src\\"
    ]
}",
}
`;
