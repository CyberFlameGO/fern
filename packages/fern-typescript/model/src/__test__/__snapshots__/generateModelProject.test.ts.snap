// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateModelProject fern IR 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/commons/_types/WithDocs.ts": "export interface WithDocs {
    docs: string | null | undefined;
}
",
  "/commons/_types/index.ts": "export * from \\"./WithDocs\\";
",
  "/commons/index.ts": "export * from \\"./_types\\";
",
  "/errors/_types/ErrorDeclaration.ts": "import * as model from \\"../..\\";

export interface ErrorDeclaration extends model.commons.WithDocs {
    name: model.errors.ErrorName;
    type: model.types.Type;
    http: model.errors.HttpErrorConfiguration | null | undefined;
}
",
  "/errors/_types/ErrorName.ts": "import * as model from \\"../..\\";

export interface ErrorName {
    fernFilepath: model.types.FernFilepath;
    name: string;
}
",
  "/errors/_types/HttpErrorConfiguration.ts": "export interface HttpErrorConfiguration {
    statusCode: number;
}
",
  "/errors/_types/index.ts": "export * from \\"./ErrorDeclaration\\";
export * from \\"./ErrorName\\";
export * from \\"./HttpErrorConfiguration\\";
",
  "/errors/index.ts": "export * from \\"./_types\\";
",
  "/generators/config/_types/GeneratorConfig.ts": "import * as model from \\"../../..\\";

export interface GeneratorConfig {
    irFilepath: string;
    output: model.generators.config.GeneratorOutputConfig;
    publish: model.generators.config.GeneratorPublishConfig | null | undefined;
    workspaceName: string;
    organization: string;
    helpers: model.generators.config.GeneratorHelpers;
    customConfig: Record<string, string>;
}
",
  "/generators/config/_types/GeneratorHelperReference.ts": "export interface GeneratorHelperReference {
    name: string;
    version: string;
    absolutePath: string;
}
",
  "/generators/config/_types/GeneratorHelpers.ts": "import * as model from \\"../../..\\";

export interface GeneratorHelpers {
    encodings: Record<string, model.generators.config.GeneratorHelperReference>;
}
",
  "/generators/config/_types/GeneratorOutputConfig.ts": "export interface GeneratorOutputConfig {
    path: string;
}
",
  "/generators/config/_types/GeneratorPublishConfig.ts": "import * as model from \\"../../..\\";

export interface GeneratorPublishConfig {
    registries: model.generators.config.GeneratorRegistriesConfig;
    version: string;
}
",
  "/generators/config/_types/GeneratorRegistriesConfig.ts": "import * as model from \\"../../..\\";

export interface GeneratorRegistriesConfig {
    maven: model.generators.config.MavenRegistryConfig;
    npm: model.generators.config.NpmRegistryConfig;
}
",
  "/generators/config/_types/MavenRegistryConfig.ts": "export interface MavenRegistryConfig {
    registryUrl: string;
    username: string;
    password: string;
}
",
  "/generators/config/_types/NpmRegistryConfig.ts": "export interface NpmRegistryConfig {
    registryUrl: string;
    token: string;
}
",
  "/generators/config/_types/index.ts": "export * from \\"./GeneratorConfig\\";
export * from \\"./GeneratorOutputConfig\\";
export * from \\"./GeneratorPublishConfig\\";
export * from \\"./GeneratorRegistriesConfig\\";
export * from \\"./MavenRegistryConfig\\";
export * from \\"./NpmRegistryConfig\\";
export * from \\"./GeneratorHelpers\\";
export * from \\"./GeneratorHelperReference\\";
",
  "/generators/config/index.ts": "export * from \\"./_types\\";
",
  "/generators/index.ts": "export * as config from \\"./config\\";
",
  "/index.ts": "export * as commons from \\"./commons\\";
export * as errors from \\"./errors\\";
export * as generators from \\"./generators\\";
export * as ir from \\"./ir\\";
export * as services from \\"./services\\";
export * as types from \\"./types\\";
",
  "/ir/_types/IntermediateRepresentation.ts": "import * as model from \\"../..\\";

/**
 * Complete representation of the API schema
 */
export interface IntermediateRepresentation {
    workspaceName: string | null | undefined;
    /** The types described by this API */
    types: model.types.TypeDeclaration[];
    /** The services exposed by this API */
    services: model.ir.Services;
    errors: model.errors.ErrorDeclaration[];
}
",
  "/ir/_types/Services.ts": "import * as model from \\"../..\\";

export interface Services {
    http: model.services.http.HttpService[];
    websocket: model.services.websocket.WebSocketChannel[];
}
",
  "/ir/_types/index.ts": "export * from \\"./IntermediateRepresentation\\";
export * from \\"./Services\\";
",
  "/ir/index.ts": "export * from \\"./_types\\";
",
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/services/commons/_types/CustomWireMessageEncoding.ts": "export interface CustomWireMessageEncoding {
    encoding: string;
}
",
  "/services/commons/_types/Encoding.ts": "import { services } from \\"../../..\\";

export type Encoding =
    | Encoding.Json
    | Encoding.Custom;

export declare namespace Encoding {
    interface Json {
        _type: \\"json\\";
    }

    interface Custom extends services.commons.CustomWireMessageEncoding {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        json: () => Result;
        custom: (value: services.commons.CustomWireMessageEncoding) => Result;
        _unknown: () => Result;
    }
}

export const Encoding = {
    json: (): Encoding.Json => ({
        _type: \\"json\\"
    }),

    custom: (value: services.commons.CustomWireMessageEncoding): Encoding.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: Encoding, visitor: Encoding._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"json\\": return visitor.json();
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): Encoding[\\"_type\\"][] => [\\"json\\", \\"custom\\"],
} as const;
",
  "/services/commons/_types/FailedResponse.ts": "import * as model from \\"../../..\\";

export interface FailedResponse extends model.commons.WithDocs {
    discriminant: string;
    errorProperties: model.services.commons.ResponseErrorProperties;
    errors: model.services.commons.ResponseError[];
}
",
  "/services/commons/_types/ResponseError.ts": "import * as model from \\"../../..\\";

export interface ResponseError extends model.commons.WithDocs {
    discriminantValue: string;
    error: model.errors.ErrorName;
}
",
  "/services/commons/_types/ResponseErrorProperties.ts": "export interface ResponseErrorProperties {
    errorInstanceId: string;
}
",
  "/services/commons/_types/ServiceName.ts": "import * as model from \\"../../..\\";

export interface ServiceName {
    fernFilepath: model.types.FernFilepath;
    name: string;
}
",
  "/services/commons/_types/index.ts": "export * from \\"./ServiceName\\";
export * from \\"./Encoding\\";
export * from \\"./CustomWireMessageEncoding\\";
export * from \\"./FailedResponse\\";
export * from \\"./ResponseErrorProperties\\";
export * from \\"./ResponseError\\";
",
  "/services/commons/index.ts": "export * from \\"./_types\\";
",
  "/services/http/_types/EndpointId.ts": "export type EndpointId = string & {
    __EndpointId: void;
};

export const EndpointId = {
    of: (value: string): EndpointId => value as EndpointId
};
",
  "/services/http/_types/HttpAuth.ts": "export type HttpAuth =
    | \\"BEARER\\"
    | \\"NONE\\";

export const HttpAuth = {
    Bearer: \\"BEARER\\",
    None: \\"NONE\\",

    _visit: <Result>(value: HttpAuth, visitor: HttpAuth._Visitor<Result>): Result => {
        switch (value) {
            case HttpAuth.Bearer: return visitor.bearer();
            case HttpAuth.None: return visitor.none();
            default: return visitor._unknown();
        }
    },

    _values: (): HttpAuth[] => [HttpAuth.Bearer, HttpAuth.None],
} as const;

export declare namespace HttpAuth {
    type Bearer = \\"BEARER\\";
    type None = \\"NONE\\";

    export interface _Visitor<Result> {
        bearer: () => Result;
        none: () => Result;
        _unknown: () => Result;
    }
}
",
  "/services/http/_types/HttpEndpoint.ts": "import * as model from \\"../../..\\";

export interface HttpEndpoint extends model.commons.WithDocs {
    endpointId: model.services.http.EndpointId;
    method: model.services.http.HttpMethod;
    headers: model.services.http.HttpHeader[];
    path: model.services.http.HttpPath;
    pathParameters: model.services.http.PathParameter[];
    queryParameters: model.services.http.QueryParameter[];
    request: model.services.http.HttpRequest;
    response: model.services.http.HttpResponse;
    auth: model.services.http.HttpAuth;
}
",
  "/services/http/_types/HttpHeader.ts": "import * as model from \\"../../..\\";

export interface HttpHeader extends model.commons.WithDocs {
    header: string;
    valueType: model.types.TypeReference;
}
",
  "/services/http/_types/HttpMethod.ts": "export type HttpMethod =
    | \\"GET\\"
    | \\"POST\\"
    | \\"PUT\\"
    | \\"PATCH\\"
    | \\"DELETE\\";

export const HttpMethod = {
    Get: \\"GET\\",
    Post: \\"POST\\",
    Put: \\"PUT\\",
    Patch: \\"PATCH\\",
    Delete: \\"DELETE\\",

    _visit: <Result>(value: HttpMethod, visitor: HttpMethod._Visitor<Result>): Result => {
        switch (value) {
            case HttpMethod.Get: return visitor.get();
            case HttpMethod.Post: return visitor.post();
            case HttpMethod.Put: return visitor.put();
            case HttpMethod.Patch: return visitor.patch();
            case HttpMethod.Delete: return visitor.delete();
            default: return visitor._unknown();
        }
    },

    _values: (): HttpMethod[] => [HttpMethod.Get, HttpMethod.Post, HttpMethod.Put, HttpMethod.Patch, HttpMethod.Delete],
} as const;

export declare namespace HttpMethod {
    type Get = \\"GET\\";
    type Post = \\"POST\\";
    type Put = \\"PUT\\";
    type Patch = \\"PATCH\\";
    type Delete = \\"DELETE\\";

    export interface _Visitor<Result> {
        get: () => Result;
        post: () => Result;
        put: () => Result;
        patch: () => Result;
        delete: () => Result;
        _unknown: () => Result;
    }
}
",
  "/services/http/_types/HttpOkResponse.ts": "import * as model from \\"../../..\\";

export interface HttpOkResponse extends model.commons.WithDocs {
    type: model.types.Type;
}
",
  "/services/http/_types/HttpPath.ts": "import * as model from \\"../../..\\";

export interface HttpPath {
    head: string;
    parts: model.services.http.HttpPathPart[];
}
",
  "/services/http/_types/HttpPathPart.ts": "export interface HttpPathPart {
    pathParameter: string;
    tail: string;
}
",
  "/services/http/_types/HttpRequest.ts": "import * as model from \\"../../..\\";

export interface HttpRequest extends model.commons.WithDocs {
    encoding: model.services.commons.Encoding;
    type: model.types.Type;
}
",
  "/services/http/_types/HttpResponse.ts": "import * as model from \\"../../..\\";

export interface HttpResponse extends model.commons.WithDocs {
    encoding: model.services.commons.Encoding;
    ok: model.services.http.HttpOkResponse;
    failed: model.services.commons.FailedResponse;
}
",
  "/services/http/_types/HttpService.ts": "import * as model from \\"../../..\\";

export interface HttpService extends model.commons.WithDocs {
    name: model.services.commons.ServiceName;
    basePath: string | null | undefined;
    endpoints: model.services.http.HttpEndpoint[];
    headers: model.services.http.HttpHeader[];
}
",
  "/services/http/_types/PathParameter.ts": "import * as model from \\"../../..\\";

export interface PathParameter extends model.commons.WithDocs {
    key: string;
    valueType: model.types.TypeReference;
}
",
  "/services/http/_types/QueryParameter.ts": "import * as model from \\"../../..\\";

export interface QueryParameter extends model.commons.WithDocs {
    key: string;
    valueType: model.types.TypeReference;
}
",
  "/services/http/_types/index.ts": "export * from \\"./EndpointId\\";
export * from \\"./HttpService\\";
export * from \\"./HttpAuth\\";
export * from \\"./HttpEndpoint\\";
export * from \\"./HttpPath\\";
export * from \\"./HttpPathPart\\";
export * from \\"./HttpMethod\\";
export * from \\"./HttpHeader\\";
export * from \\"./PathParameter\\";
export * from \\"./QueryParameter\\";
export * from \\"./HttpRequest\\";
export * from \\"./HttpResponse\\";
export * from \\"./HttpOkResponse\\";
",
  "/services/http/index.ts": "export * from \\"./_types\\";
",
  "/services/index.ts": "export * as commons from \\"./commons\\";
export * as http from \\"./http\\";
export * as websocket from \\"./websocket\\";
",
  "/services/websocket/_types/WebSocketChannel.ts": "import * as model from \\"../../..\\";

export interface WebSocketChannel extends model.commons.WithDocs {
    name: model.services.commons.ServiceName;
    path: string;
    client: model.services.websocket.WebSocketMessenger;
    server: model.services.websocket.WebSocketMessenger;
    operationProperties: model.services.websocket.WebSocketOperationProperties;
}
",
  "/services/websocket/_types/WebSocketMessenger.ts": "import * as model from \\"../../..\\";

export interface WebSocketMessenger {
    operations: model.services.websocket.WebSocketOperation[];
}
",
  "/services/websocket/_types/WebSocketOkResponse.ts": "import * as model from \\"../../..\\";

export interface WebSocketOkResponse extends model.commons.WithDocs {
    type: model.types.Type;
}
",
  "/services/websocket/_types/WebSocketOperation.ts": "import * as model from \\"../../..\\";

export interface WebSocketOperation extends model.commons.WithDocs {
    operationId: string;
    request: model.services.websocket.WebSocketRequest;
    response: model.services.websocket.WebSocketResponse;
}
",
  "/services/websocket/_types/WebSocketOperationProperties.ts": "export interface WebSocketOperationProperties {
    id: string;
    operation: string;
    body: string;
}
",
  "/services/websocket/_types/WebSocketRequest.ts": "import * as model from \\"../../..\\";

export interface WebSocketRequest extends model.commons.WithDocs {
    encoding: model.services.commons.Encoding;
    type: model.types.Type;
}
",
  "/services/websocket/_types/WebSocketResponse.ts": "import * as model from \\"../../..\\";

export interface WebSocketResponse extends model.commons.WithDocs {
    encoding: model.services.commons.Encoding;
    ok: model.services.websocket.WebSocketOkResponse;
    failed: model.services.commons.FailedResponse;
}
",
  "/services/websocket/_types/index.ts": "export * from \\"./WebSocketChannel\\";
export * from \\"./WebSocketMessenger\\";
export * from \\"./WebSocketOperation\\";
export * from \\"./WebSocketRequest\\";
export * from \\"./WebSocketResponse\\";
export * from \\"./WebSocketOkResponse\\";
export * from \\"./WebSocketOperationProperties\\";
",
  "/services/websocket/index.ts": "export * from \\"./_types\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
  "/types/_types/AliasTypeDeclaration.ts": "import * as model from \\"../..\\";

export interface AliasTypeDeclaration {
    aliasOf: model.types.TypeReference;
}
",
  "/types/_types/ContainerType.ts": "import { types } from \\"../..\\";

export type ContainerType =
    | ContainerType.List
    | ContainerType.Map
    | ContainerType.Optional
    | ContainerType.Set;

export declare namespace ContainerType {
    interface List {
        _type: \\"list\\";
        list: types.TypeReference;
    }

    interface Map extends types.MapType {
        _type: \\"map\\";
    }

    interface Optional {
        _type: \\"optional\\";
        optional: types.TypeReference;
    }

    interface Set {
        _type: \\"set\\";
        set: types.TypeReference;
    }

    export interface _Visitor<Result> {
        list: (value: types.TypeReference) => Result;
        map: (value: types.MapType) => Result;
        optional: (value: types.TypeReference) => Result;
        set: (value: types.TypeReference) => Result;
        _unknown: () => Result;
    }
}

export const ContainerType = {
    list: (value: types.TypeReference): ContainerType.List => ({
        list: value,
        _type: \\"list\\"
    }),

    map: (value: types.MapType): ContainerType.Map => ({
        ...value,
        _type: \\"map\\"
    }),

    optional: (value: types.TypeReference): ContainerType.Optional => ({
        optional: value,
        _type: \\"optional\\"
    }),

    set: (value: types.TypeReference): ContainerType.Set => ({
        set: value,
        _type: \\"set\\"
    }),

    _visit: <Result>(value: ContainerType, visitor: ContainerType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"list\\": return visitor.list(value.list);
            case \\"map\\": return visitor.map(value);
            case \\"optional\\": return visitor.optional(value.optional);
            case \\"set\\": return visitor.set(value.set);
            default: return visitor._unknown();
        }
    },

    _types: (): ContainerType[\\"_type\\"][] => [\\"list\\", \\"map\\", \\"optional\\", \\"set\\"],
} as const;
",
  "/types/_types/DeclaredTypeName.ts": "import * as model from \\"../..\\";

export interface DeclaredTypeName {
    fernFilepath: model.types.FernFilepath;
    name: string;
}
",
  "/types/_types/EnumTypeDeclaration.ts": "import * as model from \\"../..\\";

export interface EnumTypeDeclaration {
    values: model.types.EnumValue[];
}
",
  "/types/_types/EnumValue.ts": "import * as model from \\"../..\\";

export interface EnumValue extends model.commons.WithDocs {
    /** Name must start with an alphabet. */
    name: string;
    value: string;
}
",
  "/types/_types/FernFilepath.ts": "export type FernFilepath = string[];
",
  "/types/_types/MapType.ts": "import * as model from \\"../..\\";

export interface MapType {
    keyType: model.types.TypeReference;
    valueType: model.types.TypeReference;
}
",
  "/types/_types/ObjectProperty.ts": "import * as model from \\"../..\\";

export interface ObjectProperty extends model.commons.WithDocs {
    key: string;
    valueType: model.types.TypeReference;
}
",
  "/types/_types/ObjectTypeDeclaration.ts": "import * as model from \\"../..\\";

export interface ObjectTypeDeclaration {
    /** A list of other types to inherit from */
    extends: model.types.DeclaredTypeName[];
    properties: model.types.ObjectProperty[];
}
",
  "/types/_types/PrimitiveType.ts": "export type PrimitiveType =
    | \\"INTEGER\\"
    | \\"DOUBLE\\"
    | \\"STRING\\"
    | \\"BOOLEAN\\"
    /**
     * Within the range -2^53 to 2^53 */
    | \\"LONG\\"
    | \\"DATE_TIME\\"
    | \\"UUID\\";

export const PrimitiveType = {
    Integer: \\"INTEGER\\",
    Double: \\"DOUBLE\\",
    String: \\"STRING\\",
    Boolean: \\"BOOLEAN\\",
    Long: \\"LONG\\",
    DateTime: \\"DATE_TIME\\",
    Uuid: \\"UUID\\",

    _visit: <Result>(value: PrimitiveType, visitor: PrimitiveType._Visitor<Result>): Result => {
        switch (value) {
            case PrimitiveType.Integer: return visitor.integer();
            case PrimitiveType.Double: return visitor.double();
            case PrimitiveType.String: return visitor.string();
            case PrimitiveType.Boolean: return visitor.boolean();
            case PrimitiveType.Long: return visitor.long();
            case PrimitiveType.DateTime: return visitor.dateTime();
            case PrimitiveType.Uuid: return visitor.uuid();
            default: return visitor._unknown();
        }
    },

    _values: (): PrimitiveType[] => [PrimitiveType.Integer, PrimitiveType.Double, PrimitiveType.String, PrimitiveType.Boolean, PrimitiveType.Long, PrimitiveType.DateTime, PrimitiveType.Uuid],
} as const;

export declare namespace PrimitiveType {
    type Integer = \\"INTEGER\\";
    type Double = \\"DOUBLE\\";
    type String = \\"STRING\\";
    type Boolean = \\"BOOLEAN\\";
    type Long = \\"LONG\\";
    type DateTime = \\"DATE_TIME\\";
    type Uuid = \\"UUID\\";

    export interface _Visitor<Result> {
        integer: () => Result;
        double: () => Result;
        string: () => Result;
        boolean: () => Result;
        long: () => Result;
        dateTime: () => Result;
        uuid: () => Result;
        _unknown: () => Result;
    }
}
",
  "/types/_types/SingleUnionType.ts": "import * as model from \\"../..\\";

export interface SingleUnionType extends model.commons.WithDocs {
    discriminantValue: string;
    valueType: model.types.TypeReference;
}
",
  "/types/_types/Type.ts": "import { types } from \\"../..\\";

export type Type =
    | Type.Alias
    | Type.Enum
    | Type.Object
    | Type.Union;

export declare namespace Type {
    interface Alias extends types.AliasTypeDeclaration {
        _type: \\"alias\\";
    }

    interface Enum extends types.EnumTypeDeclaration {
        _type: \\"enum\\";
    }

    interface Object extends types.ObjectTypeDeclaration {
        _type: \\"object\\";
    }

    interface Union extends types.UnionTypeDeclaration {
        _type: \\"union\\";
    }

    export interface _Visitor<Result> {
        alias: (value: types.AliasTypeDeclaration) => Result;
        enum: (value: types.EnumTypeDeclaration) => Result;
        object: (value: types.ObjectTypeDeclaration) => Result;
        union: (value: types.UnionTypeDeclaration) => Result;
        _unknown: () => Result;
    }
}

export const Type = {
    alias: (value: types.AliasTypeDeclaration): Type.Alias => ({
        ...value,
        _type: \\"alias\\"
    }),

    enum: (value: types.EnumTypeDeclaration): Type.Enum => ({
        ...value,
        _type: \\"enum\\"
    }),

    object: (value: types.ObjectTypeDeclaration): Type.Object => ({
        ...value,
        _type: \\"object\\"
    }),

    union: (value: types.UnionTypeDeclaration): Type.Union => ({
        ...value,
        _type: \\"union\\"
    }),

    _visit: <Result>(value: Type, visitor: Type._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"alias\\": return visitor.alias(value);
            case \\"enum\\": return visitor.enum(value);
            case \\"object\\": return visitor.object(value);
            case \\"union\\": return visitor.union(value);
            default: return visitor._unknown();
        }
    },

    _types: (): Type[\\"_type\\"][] => [\\"alias\\", \\"enum\\", \\"object\\", \\"union\\"],
} as const;
",
  "/types/_types/TypeDeclaration.ts": "import * as model from \\"../..\\";

/**
 * A type, which is a name and a shape
 */
export interface TypeDeclaration extends model.commons.WithDocs {
    name: model.types.DeclaredTypeName;
    shape: model.types.Type;
}
",
  "/types/_types/TypeReference.ts": "import { types } from \\"../..\\";

export type TypeReference =
    | TypeReference.Container
    | TypeReference.Named
    | TypeReference.Primitive
    | TypeReference.Unknown
    | TypeReference.Void;

export declare namespace TypeReference {
    interface Container {
        _type: \\"container\\";
        container: types.ContainerType;
    }

    interface Named extends types.DeclaredTypeName {
        _type: \\"named\\";
    }

    interface Primitive {
        _type: \\"primitive\\";
        primitive: types.PrimitiveType;
    }

    interface Unknown {
        _type: \\"unknown\\";
    }

    interface Void {
        _type: \\"void\\";
    }

    export interface _Visitor<Result> {
        container: (value: types.ContainerType) => Result;
        named: (value: types.DeclaredTypeName) => Result;
        primitive: (value: types.PrimitiveType) => Result;
        unknown: () => Result;
        void: () => Result;
        _unknown: () => Result;
    }
}

export const TypeReference = {
    container: (value: types.ContainerType): TypeReference.Container => ({
        container: value,
        _type: \\"container\\"
    }),

    named: (value: types.DeclaredTypeName): TypeReference.Named => ({
        ...value,
        _type: \\"named\\"
    }),

    primitive: (value: types.PrimitiveType): TypeReference.Primitive => ({
        primitive: value,
        _type: \\"primitive\\"
    }),

    unknown: (): TypeReference.Unknown => ({
        _type: \\"unknown\\"
    }),

    void: (): TypeReference.Void => ({
        _type: \\"void\\"
    }),

    _visit: <Result>(value: TypeReference, visitor: TypeReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"container\\": return visitor.container(value.container);
            case \\"named\\": return visitor.named(value);
            case \\"primitive\\": return visitor.primitive(value.primitive);
            case \\"unknown\\": return visitor.unknown();
            case \\"void\\": return visitor.void();
            default: return visitor._unknown();
        }
    },

    _types: (): TypeReference[\\"_type\\"][] => [\\"container\\", \\"named\\", \\"primitive\\", \\"unknown\\", \\"void\\"],
} as const;
",
  "/types/_types/UnionTypeDeclaration.ts": "import * as model from \\"../..\\";

export interface UnionTypeDeclaration {
    discriminant: string;
    types: model.types.SingleUnionType[];
}
",
  "/types/_types/index.ts": "export * from \\"./TypeDeclaration\\";
export * from \\"./DeclaredTypeName\\";
export * from \\"./FernFilepath\\";
export * from \\"./Type\\";
export * from \\"./AliasTypeDeclaration\\";
export * from \\"./EnumTypeDeclaration\\";
export * from \\"./EnumValue\\";
export * from \\"./ObjectTypeDeclaration\\";
export * from \\"./ObjectProperty\\";
export * from \\"./UnionTypeDeclaration\\";
export * from \\"./SingleUnionType\\";
export * from \\"./TypeReference\\";
export * from \\"./ContainerType\\";
export * from \\"./MapType\\";
export * from \\"./PrimitiveType\\";
",
  "/types/index.ts": "export * from \\"./_types\\";
",
}
`;

exports[`generateModelProject posts 1`] = `
Object {
  "/.npmignore": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
  "/commons/_types/PostId.ts": "/**
 * An ID of a blog post
 */
export type PostId = string & {
    __PostId: void;
};

export const PostId = {
    of: (value: string): PostId => value as PostId
};
",
  "/commons/_types/index.ts": "export * from \\"./PostId\\";
",
  "/commons/index.ts": "export * from \\"./_types\\";
",
  "/index.ts": "export * as commons from \\"./commons\\";
export * as posts from \\"./posts\\";
",
  "/package.json": "{
    \\"name\\": \\"posts\\",
    \\"version\\": \\"0.0.0\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
  "/posts/_errors/PostNotFoundError.ts": "export type PostNotFoundError = string & {
    __PostNotFoundError: void;
};

export const PostNotFoundError = {
    of: (value: string): PostNotFoundError => value as PostNotFoundError
};
",
  "/posts/_errors/index.ts": "export * from \\"./PostNotFoundError\\";
",
  "/posts/_types/Author.ts": "export type Author =
    | Author.Anonymous
    | Author.Named;

export declare namespace Author {
    interface Anonymous {
        _type: \\"anonymous\\";
    }

    interface Named {
        _type: \\"named\\";
        named: string;
    }

    export interface _Visitor<Result> {
        anonymous: () => Result;
        named: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const Author = {
    anonymous: (): Author.Anonymous => ({
        _type: \\"anonymous\\"
    }),

    named: (value: string): Author.Named => ({
        named: value,
        _type: \\"named\\"
    }),

    _visit: <Result>(value: Author, visitor: Author._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"anonymous\\": return visitor.anonymous();
            case \\"named\\": return visitor.named(value.named);
            default: return visitor._unknown();
        }
    },

    _types: (): Author[\\"_type\\"][] => [\\"anonymous\\", \\"named\\"],
} as const;
",
  "/posts/_types/BlogPostReference.ts": "import { posts } from \\"../..\\";

export type BlogPostReference =
    | BlogPostReference.Post;

export declare namespace BlogPostReference {
    interface Post extends posts.Post {
        _type: \\"post\\";
    }

    export interface _Visitor<Result> {
        post: (value: posts.Post) => Result;
        _unknown: () => Result;
    }
}

export const BlogPostReference = {
    post: (value: posts.Post): BlogPostReference.Post => ({
        ...value,
        _type: \\"post\\"
    }),

    _visit: <Result>(value: BlogPostReference, visitor: BlogPostReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"post\\": return visitor.post(value);
            default: return visitor._unknown();
        }
    },

    _types: (): BlogPostReference[\\"_type\\"][] => [\\"post\\"],
} as const;
",
  "/posts/_types/CreatePostRequest.ts": "import * as model from \\"../..\\";

export interface CreatePostRequest {
    title: string;
    author: model.posts.Author;
    content: string;
}
",
  "/posts/_types/GetPostResponse.ts": "export interface GetPostResponse {
    a: number;
}
",
  "/posts/_types/Post.ts": "import * as model from \\"../..\\";

/**
 * A blog post
 */
export interface Post {
    id: model.commons.PostId;
    type: model.posts.PostType;
    title: string;
    author: model.posts.Author;
    content: string;
    customConfig: unknown;
}
",
  "/posts/_types/PostType.ts": "export type PostType =
    | \\"LONG\\"
    | \\"SHORT\\";

export const PostType = {
    Long: \\"LONG\\",
    Short: \\"SHORT\\",

    _visit: <Result>(value: PostType, visitor: PostType._Visitor<Result>): Result => {
        switch (value) {
            case PostType.Long: return visitor.long();
            case PostType.Short: return visitor.short();
            default: return visitor._unknown();
        }
    },

    _values: (): PostType[] => [PostType.Long, PostType.Short],
} as const;

export declare namespace PostType {
    type Long = \\"LONG\\";
    type Short = \\"SHORT\\";

    export interface _Visitor<Result> {
        long: () => Result;
        short: () => Result;
        _unknown: () => Result;
    }
}
",
  "/posts/_types/index.ts": "export * from \\"./Post\\";
export * from \\"./BlogPostReference\\";
export * from \\"./PostType\\";
export * from \\"./Author\\";
export * from \\"./CreatePostRequest\\";
export * from \\"./GetPostResponse\\";
",
  "/posts/index.ts": "export * from \\"./_types\\";
export * from \\"./_errors\\";
",
  "/tsconfig.json": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
}
`;
